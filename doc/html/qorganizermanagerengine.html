<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qorganizermanagerengine.cpp -->
  <title>Qt 1.2: QOrganizerManagerEngine Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>QtMobility Reference Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="qtorganizer.html">QtOrganizer</a></li>
              <li>QOrganizerManagerEngine</li>
    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QOrganizerManagerEngine Class Reference</h1>
<!-- $$$QOrganizerManagerEngine-brief -->
<p>The QOrganizerManagerEngine class provides the interface for all implementations of the organizer item manager backend functionality. <a href="#details">More...</a></p>
<!-- @@@QOrganizerManagerEngine -->
<pre class="highlightedCode brush: cpp"> #include &lt;QOrganizerManagerEngine&gt;</pre><p>Inherits <a href="http://qt.nokia.com/doc/4.7/qobject.html">QObject</a>.</p>
<p>Inherited by <a href="qorganizeriteminvalidengine.html">QOrganizerItemInvalidEngine</a>.</p>
<p>This class was introduced in Qt Mobility 1.1.</p>
<ul>
<li><a href="qorganizermanagerengine-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#QOrganizerManagerEngine">QOrganizerManagerEngine</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#cancelRequest">cancelRequest</a></b> ( QOrganizerAbstractRequest * <i>req</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOrganizerCollection </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#collection">collection</a></b> ( const QOrganizerCollectionId &amp; <i>collectionId</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QOrganizerCollection&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#collections">collections</a></b> ( QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOrganizerCollection </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#compatibleCollection">compatibleCollection</a></b> ( const QOrganizerCollection &amp; <i>original</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOrganizerItem </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#compatibleItem">compatibleItem</a></b> ( const QOrganizerItem &amp; <i>original</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOrganizerCollection </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#defaultCollection">defaultCollection</a></b> ( QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOrganizerItemDetailDefinition </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#detailDefinition">detailDefinition</a></b> ( const QString &amp; <i>definitionName</i>, const QString &amp; <i>organizeritemType</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QMap&lt;QString, QOrganizerItemDetailDefinition&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#detailDefinitions">detailDefinitions</a></b> ( const QString &amp; <i>organizeritemType</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#hasFeature">hasFeature</a></b> ( QOrganizerManager::ManagerFeature <i>feature</i>, const QString &amp; <i>organizeritemType</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#isFilterSupported">isFilterSupported</a></b> ( const QOrganizerItemFilter &amp; <i>filter</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QOrganizerItem </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#item">item</a></b> ( const QOrganizerItemId &amp; <i>organizeritemId</i>, const QOrganizerItemFetchHint &amp; <i>fetchHint</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QOrganizerItemId&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemIds">itemIds</a></b> ( const QDateTime &amp; <i>startDate</i>, const QDateTime &amp; <i>endDate</i>, const QOrganizerItemFilter &amp; <i>filter</i>, const QList&lt;QOrganizerItemSortOrder&gt; &amp; <i>sortOrders</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QOrganizerItem&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemOccurrences">itemOccurrences</a></b> ( const QOrganizerItem &amp; <i>parentItem</i>, const QDateTime &amp; <i>periodStart</i>, const QDateTime &amp; <i>periodEnd</i>, int <i>maxCount</i>, const QOrganizerItemFetchHint &amp; <i>fetchHint</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QOrganizerItem&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#items">items</a></b> ( const QDateTime &amp; <i>startDate</i>, const QDateTime &amp; <i>endDate</i>, const QOrganizerItemFilter &amp; <i>filter</i>, const QList&lt;QOrganizerItemSortOrder&gt; &amp; <i>sortOrders</i>, const QOrganizerItemFetchHint &amp; <i>fetchHint</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QOrganizerItem&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemsForExport">itemsForExport</a></b> ( const QDateTime &amp; <i>startDate</i>, const QDateTime &amp; <i>endDate</i>, const QOrganizerItemFilter &amp; <i>filter</i>, const QList&lt;QOrganizerItemSortOrder&gt; &amp; <i>sortOrders</i>, const QOrganizerItemFetchHint &amp; <i>fetchHint</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QString </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#managerName">managerName</a></b> () const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QMap&lt;QString, QString&gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#managerParameters">managerParameters</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#managerUri">managerUri</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#managerVersion">managerVersion</a></b> () const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#removeCollection">removeCollection</a></b> ( const QOrganizerCollectionId &amp; <i>collectionId</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#removeDetailDefinition">removeDetailDefinition</a></b> ( const QString &amp; <i>definitionName</i>, const QString &amp; <i>organizeritemType</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#removeItem">removeItem</a></b> ( const QOrganizerItemId &amp; <i>organizeritemId</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#removeItems">removeItems</a></b> ( const QList&lt;QOrganizerItemId&gt; &amp; <i>organizeritemIds</i>, QMap&lt;int, QOrganizerManager::Error&gt; * <i>errorMap</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#requestDestroyed">requestDestroyed</a></b> ( QOrganizerAbstractRequest * <i>req</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#saveCollection">saveCollection</a></b> ( QOrganizerCollection * <i>collection</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#saveDetailDefinition">saveDetailDefinition</a></b> ( const QOrganizerItemDetailDefinition &amp; <i>def</i>, const QString &amp; <i>organizeritemType</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#saveItem">saveItem</a></b> ( QOrganizerItem * <i>item</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#saveItems">saveItems</a></b> ( QList&lt;QOrganizerItem&gt; * <i>items</i>, QMap&lt;int, QOrganizerManager::Error&gt; * <i>errorMap</i>, QOrganizerManager::Error * <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#startRequest">startRequest</a></b> ( QOrganizerAbstractRequest * <i>req</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QStringList </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#supportedItemTypes">supportedItemTypes</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#validateCollection">validateCollection</a></b> ( const QOrganizerCollection &amp; <i>collection</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#validateDefinition">validateDefinition</a></b> ( const QOrganizerItemDetailDefinition &amp; <i>definition</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#validateItem">validateItem</a></b> ( const QOrganizerItem &amp; <i>item</i>, QOrganizerManager::Error * <i>error</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#waitForRequestFinished">waitForRequestFinished</a></b> ( QOrganizerAbstractRequest * <i>req</i>, int <i>msecs</i> )</td></tr>
</table>
<ul>
<li class="fn">29 public functions inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#collectionsAdded">collectionsAdded</a></b> ( const QList&lt;QOrganizerCollectionId&gt; &amp; <i>collectionIds</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#collectionsChanged">collectionsChanged</a></b> ( const QList&lt;QOrganizerCollectionId&gt; &amp; <i>collectionIds</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#collectionsRemoved">collectionsRemoved</a></b> ( const QList&lt;QOrganizerCollectionId&gt; &amp; <i>collectionIds</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#dataChanged">dataChanged</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemsAdded">itemsAdded</a></b> ( const QList&lt;QOrganizerItemId&gt; &amp; <i>organizeritemIds</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemsChanged">itemsChanged</a></b> ( const QList&lt;QOrganizerItemId&gt; &amp; <i>organizeritemIds</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemsRemoved">itemsRemoved</a></b> ( const QList&lt;QOrganizerItemId&gt; &amp; <i>organizeritemIds</i> )</td></tr>
</table>
<ul>
<li class="fn">1 signal inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#addSorted">addSorted</a></b> ( QList&lt;QOrganizerItem&gt; * <i>sorted</i>, const QOrganizerItem &amp; <i>toAdd</i>, const QList&lt;QOrganizerItemSortOrder&gt; &amp; <i>sortOrders</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOrganizerItemFilter </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#canonicalizedFilter">canonicalizedFilter</a></b> ( const QOrganizerItemFilter &amp; <i>filter</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#compareItem">compareItem</a></b> ( const QOrganizerItem &amp; <i>a</i>, const QOrganizerItem &amp; <i>b</i>, const QList&lt;QOrganizerItemSortOrder&gt; &amp; <i>sortOrders</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#compareVariant">compareVariant</a></b> ( const QVariant &amp; <i>first</i>, const QVariant &amp; <i>second</i>, Qt::CaseSensitivity <i>sensitivity</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QOrganizerCollectionEngineId * </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#engineCollectionId">engineCollectionId</a></b> ( const QOrganizerCollectionId &amp; <i>id</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QOrganizerItemEngineId * </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#engineItemId">engineItemId</a></b> ( const QOrganizerItemId &amp; <i>id</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#isItemBetweenDates">isItemBetweenDates</a></b> ( const QOrganizerItem &amp; <i>item</i>, const QDateTime &amp; <i>startPeriod</i>, const QDateTime &amp; <i>endPeriod</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#itemLessThan">itemLessThan</a></b> ( const QOrganizerItem &amp; <i>a</i>, const QOrganizerItem &amp; <i>b</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap&lt;QString, QMap&lt;QString, QOrganizerItemDetailDefinition&gt; &gt; </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#schemaDefinitions">schemaDefinitions</a></b> ( int <i>version</i> = 1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#setDetailAccessConstraints">setDetailAccessConstraints</a></b> ( QOrganizerItemDetail * <i>detail</i>, QOrganizerItemDetail::AccessConstraints <i>constraints</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#testFilter">testFilter</a></b> ( const QOrganizerItemFilter &amp; <i>filter</i>, const QOrganizerItem &amp; <i>item</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateCollectionFetchRequest">updateCollectionFetchRequest</a></b> ( QOrganizerCollectionFetchRequest * <i>req</i>, const QList&lt;QOrganizerCollection&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateCollectionRemoveRequest">updateCollectionRemoveRequest</a></b> ( QOrganizerCollectionRemoveRequest * <i>req</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateCollectionSaveRequest">updateCollectionSaveRequest</a></b> ( QOrganizerCollectionSaveRequest * <i>req</i>, const QList&lt;QOrganizerCollection&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateDefinitionFetchRequest">updateDefinitionFetchRequest</a></b> ( QOrganizerItemDetailDefinitionFetchRequest * <i>req</i>, const QMap&lt;QString, QOrganizerItemDetailDefinition&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateDefinitionRemoveRequest">updateDefinitionRemoveRequest</a></b> ( QOrganizerItemDetailDefinitionRemoveRequest * <i>req</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateDefinitionSaveRequest">updateDefinitionSaveRequest</a></b> ( QOrganizerItemDetailDefinitionSaveRequest * <i>req</i>, const QList&lt;QOrganizerItemDetailDefinition&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateItemFetchForExportRequest">updateItemFetchForExportRequest</a></b> ( QOrganizerItemFetchForExportRequest * <i>req</i>, const QList&lt;QOrganizerItem&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateItemFetchRequest">updateItemFetchRequest</a></b> ( QOrganizerItemFetchRequest * <i>req</i>, const QList&lt;QOrganizerItem&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateItemIdFetchRequest">updateItemIdFetchRequest</a></b> ( QOrganizerItemIdFetchRequest * <i>req</i>, const QList&lt;QOrganizerItemId&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateItemOccurrenceFetchRequest">updateItemOccurrenceFetchRequest</a></b> ( QOrganizerItemOccurrenceFetchRequest * <i>req</i>, const QList&lt;QOrganizerItem&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateItemRemoveRequest">updateItemRemoveRequest</a></b> ( QOrganizerItemRemoveRequest * <i>req</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateItemSaveRequest">updateItemSaveRequest</a></b> ( QOrganizerItemSaveRequest * <i>req</i>, const QList&lt;QOrganizerItem&gt; &amp; <i>result</i>, QOrganizerManager::Error <i>error</i>, const QMap&lt;int, QOrganizerManager::Error&gt; &amp; <i>errorMap</i>, QOrganizerAbstractRequest::State <i>newState</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qorganizermanagerengine.html#updateRequestState">updateRequestState</a></b> ( QOrganizerAbstractRequest * <i>req</i>, QOrganizerAbstractRequest::State <i>state</i> )</td></tr>
</table>
<ul>
<li class="fn">4 static public members inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#static-public-members">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#public-variables">QObject</a></li>
<li class="fn">7 protected functions inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="http://qt.nokia.com/doc/4.7/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QOrganizerManagerEngine-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QOrganizerManagerEngine class provides the interface for all implementations of the organizer item manager backend functionality.</p>
<p>Instances of this class are usually provided by a <a href="qorganizermanagerenginefactory.html">QOrganizerManagerEngineFactory</a>, which is loaded from a plugin.</p>
<p>The default implementation of this interface provides a basic level of functionality for some functions so that specific engines can simply implement the functionality that is supported by the specific organizer items engine that is being adapted.</p>
<p>More information on writing an organizer engine plugin is available in the <a href="organizerengines.html">Qt Organizer Manager Engines</a> documentation.</p>
<p>Engines that support the QOrganizerManagerEngine interface but not the QOrganizerManagerEngineV2 interface will be wrapped by the <a href="qorganizermanager.html">QOrganizerManager</a> by a class that emulates the extra functionality of the QOrganizerManagerEngineV2 interface.</p>
<p>The additional features of a V2 engine compared to the original QOrganizerManagerEngine are:</p>
<ul>
<li>The items function which takes a <i>maxCount</i> parameter</li>
<li>The result of the items functions must be sorted by date according to the sort order defined by itemLessThan</li>
<li>The corresponding changes to <a href="qorganizeritemfetchrequest.html">QOrganizerItemFetchRequest</a></li>
</ul>
</div>
<p>See also <a href="qorganizermanager.html">QOrganizerManager</a> and <a href="qorganizermanagerenginefactory.html">QOrganizerManagerEngineFactory</a>.</p>
<!-- @@@QOrganizerManagerEngine -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QOrganizerManagerEngine[overload1]$$$QOrganizerManagerEngine -->
<h3 class="fn"><a name="QOrganizerManagerEngine"></a>QOrganizerManagerEngine::QOrganizerManagerEngine ()</h3>
<p>A default, empty constructor.</p>
<!-- @@@QOrganizerManagerEngine -->
<!-- $$$addSorted[overload1]$$$addSortedQList<QOrganizerItem>*constQOrganizerItem&constQList<QOrganizerItemSortOrder>& -->
<h3 class="fn"><a name="addSorted"></a>void QOrganizerManagerEngine::addSorted ( <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; * <i>sorted</i>, const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>toAdd</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a>&gt; &amp; <i>sortOrders</i> )<tt> [static]</tt></h3>
<p>Performs insertion sort of the item <i>toAdd</i> into the <i>sorted</i> list, according to the provided <i>sortOrders</i> list. The first <a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a> in the list has the highest priority; if the item <i>toAdd</i> is deemed equal to another in the <i>sorted</i> list, the second <a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a> in the list is used (and so on until either the item is inserted or there are no more sort order objects in the list).</p>
<!-- @@@addSorted -->
<!-- $$$cancelRequest[overload1]$$$cancelRequestQOrganizerAbstractRequest* -->
<h3 class="fn"><a name="cancelRequest"></a>bool QOrganizerManagerEngine::cancelRequest ( <a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a> * <i>req</i> )<tt> [virtual]</tt></h3>
<p>Asks the manager engine to cancel the given request <i>req</i> which was previously started and is currently in a cancellable state. Returns true if cancellation of the request was started successfully, otherwise returns false.</p>
<p>See also <a href="qorganizermanagerengine.html#startRequest">startRequest</a>() and <a href="qorganizerabstractrequest.html#cancel">QOrganizerAbstractRequest::cancel</a>().</p>
<!-- @@@cancelRequest -->
<!-- $$$canonicalizedFilter[overload1]$$$canonicalizedFilterconstQOrganizerItemFilter& -->
<h3 class="fn"><a name="canonicalizedFilter"></a><a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> QOrganizerManagerEngine::canonicalizedFilter ( const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> &amp; <i>filter</i> )<tt> [static]</tt></h3>
<p>Given an input <i>filter</i>, returns the canonical version of the filter.</p>
<p>Some of the following transformations may be applied:</p>
<ul>
<li>Any QOrganizerItemInvalidFilters contained in a union filter will be removed</li>
<li>Any default QOrganizerItemFilters contained in an intersection filter will be removed</li>
<li>Any QOrganizerItemIntersectionFilters with a <a href="qorganizeriteminvalidfilter.html">QOrganizerItemInvalidFilter</a> contained will be replaced with a <a href="qorganizeriteminvalidfilter.html">QOrganizerItemInvalidFilter</a></li>
<li>Any QOrganizerItemUnionFilters with a default <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> contained will be replaced with a default <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a></li>
<li>An empty <a href="qorganizeritemintersectionfilter.html">QOrganizerItemIntersectionFilter</a> will be replaced with a QOrganizerItemDefaultFilter</li>
<li>An empty <a href="qorganizeritemunionfilter.html">QOrganizerItemUnionFilter</a> will be replaced with a <a href="qorganizeriteminvalidfilter.html">QOrganizerItemInvalidFilter</a></li>
<li>An empty <a href="qorganizeritemidfilter.html">QOrganizerItemIdFilter</a> will be replaced with a <a href="qorganizeriteminvalidfilter.html">QOrganizerItemInvalidFilter</a></li>
<li>An intersection or union filter with a single entry will be replaced by that entry</li>
<li>A <a href="qorganizeritemdetailfilter.html">QOrganizerItemDetailFilter</a> or <a href="qorganizeritemdetailrangefilter.html">QOrganizerItemDetailRangeFilter</a> with no definition name will be replaced with a <a href="qorganizeriteminvalidfilter.html">QOrganizerItemInvalidFilter</a></li>
<li>A <a href="qorganizeritemdetailrangefilter.html">QOrganizerItemDetailRangeFilter</a> with no range specified will be converted to a <a href="qorganizeritemdetailfilter.html">QOrganizerItemDetailFilter</a></li>
</ul>
<!-- @@@canonicalizedFilter -->
<!-- $$$collection[overload1]$$$collectionconstQOrganizerCollectionId&QOrganizerManager::Error* -->
<h3 class="fn"><a name="collection"></a><a href="qorganizercollection.html">QOrganizerCollection</a> QOrganizerManagerEngine::collection ( const <a href="qorganizercollectionid.html">QOrganizerCollectionId</a> &amp; <i>collectionId</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the collection identified by the given <i>collectionId</i> in the manager. Any errors encountered during this operation should be stored to <i>error</i>. If the given <i>collectionId</i> does not specify a valid collection, <i>error</i> will be set to <tt>QOrganizerManager::DoesNotExistError</tt>.</p>
<!-- @@@collection -->
<!-- $$$collections[overload1]$$$collectionsQOrganizerManager::Error* -->
<h3 class="fn"><a name="collections"></a><a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizercollection.html">QOrganizerCollection</a>&gt; QOrganizerManagerEngine::collections ( <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the list of all of the collections managed by this manager. Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@collections -->
<!-- $$$collectionsAdded[overload1]$$$collectionsAddedconstQList<QOrganizerCollectionId>& -->
<h3 class="fn"><a name="collectionsAdded"></a>void QOrganizerManagerEngine::collectionsAdded ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizercollectionid.html">QOrganizerCollectionId</a>&gt; &amp; <i>collectionIds</i> )<tt> [signal]</tt></h3>
<p>This signal should be emitted at some point once the collections identified by <i>collectionIds</i> have been added to a datastore managed by this engine. This signal must not be emitted if the <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>() signal was previously emitted for these changes.</p>
<!-- @@@collectionsAdded -->
<!-- $$$collectionsChanged[overload1]$$$collectionsChangedconstQList<QOrganizerCollectionId>& -->
<h3 class="fn"><a name="collectionsChanged"></a>void QOrganizerManagerEngine::collectionsChanged ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizercollectionid.html">QOrganizerCollectionId</a>&gt; &amp; <i>collectionIds</i> )<tt> [signal]</tt></h3>
<p>This signal should be emitted at some point once the metadata for the collections identified by <i>collectionIds</i> have been modified in a datastore managed by this engine. This signal is not emitted if one of the items in this collection has changed - <a href="qorganizermanagerengine.html#itemsChanged">itemsChanged</a>() will be emitted instead. This signal must not be emitted if the <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>() signal was previously emitted for these changes.</p>
<!-- @@@collectionsChanged -->
<!-- $$$collectionsRemoved[overload1]$$$collectionsRemovedconstQList<QOrganizerCollectionId>& -->
<h3 class="fn"><a name="collectionsRemoved"></a>void QOrganizerManagerEngine::collectionsRemoved ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizercollectionid.html">QOrganizerCollectionId</a>&gt; &amp; <i>collectionIds</i> )<tt> [signal]</tt></h3>
<p>This signal should be emitted at some point once the collections identified by <i>collectionIds</i> have been removed from a datastore managed by this engine. This signal must not be emitted if the <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>() signal was previously emitted for these changes.</p>
<!-- @@@collectionsRemoved -->
<!-- $$$compareItem[overload1]$$$compareItemconstQOrganizerItem&constQOrganizerItem&constQList<QOrganizerItemSortOrder>& -->
<h3 class="fn"><a name="compareItem"></a>int QOrganizerManagerEngine::compareItem ( const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>a</i>, const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>b</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a>&gt; &amp; <i>sortOrders</i> )<tt> [static]</tt></h3>
<p>Compares two organizer items (<i>a</i> and <i>b</i>) using the given list of <i>sortOrders</i>. Returns a negative number if <i>a</i> should appear before <i>b</i> according to the sort order, a positive number if <i>a</i> should appear after <i>b</i> according to the sort order, and zero if the two are unable to be sorted.</p>
<!-- @@@compareItem -->
<!-- $$$compareVariant[overload1]$$$compareVariantconstQVariant&constQVariant&Qt::CaseSensitivity -->
<h3 class="fn"><a name="compareVariant"></a>int QOrganizerManagerEngine::compareVariant ( const <a href="http://qt.nokia.com/doc/4.7/qvariant.html">QVariant</a> &amp; <i>first</i>, const <a href="http://qt.nokia.com/doc/4.7/qvariant.html">QVariant</a> &amp; <i>second</i>, <a href="http://qt.nokia.com/doc/4.7/qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <i>sensitivity</i> )<tt> [static]</tt></h3>
<p>Compares <i>first</i> against <i>second</i>. If the types are strings (<a href="http://qt.nokia.com/doc/4.7/qvariant.html#Type-enum">QVariant::String</a>), the <i>sensitivity</i> argument controls case sensitivity when comparing.</p>
<p>Returns: &lt;0 if <i>first</i> is less than <i>second</i> 0 if <i>first</i> is equal to <i>second</i> &gt;0 if <i>first</i> is greater than <i>second</i>.</p>
<p>The results are undefined if the variants are different types, or cannot be compared.</p>
<!-- @@@compareVariant -->
<!-- $$$compatibleCollection[overload1]$$$compatibleCollectionconstQOrganizerCollection&QOrganizerManager::Error* -->
<h3 class="fn"><a name="compatibleCollection"></a><a href="qorganizercollection.html">QOrganizerCollection</a> QOrganizerManagerEngine::compatibleCollection ( const <a href="qorganizercollection.html">QOrganizerCollection</a> &amp; <i>original</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns a pruned or modified version of the <i>original</i> collection which is valid and can be saved in the manager. The returned item might have meta data removed or arbitrarily changed. Any error which occurs will be saved to <i>error</i>. By default, modifiable collections are not supported, and so this function always returns false. Any engine which supports mutable collections should reimplement this function.</p>
<!-- @@@compatibleCollection -->
<!-- $$$compatibleItem[overload1]$$$compatibleItemconstQOrganizerItem&QOrganizerManager::Error* -->
<h3 class="fn"><a name="compatibleItem"></a><a href="qorganizeritem.html">QOrganizerItem</a> QOrganizerManagerEngine::compatibleItem ( const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>original</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns a pruned or modified version of the <i>original</i> item which is valid and can be saved in the manager. The returned item might have details removed or arbitrarily changed. Any error which occurs will be saved to <i>error</i>.</p>
<!-- @@@compatibleItem -->
<!-- $$$dataChanged[overload1]$$$dataChanged -->
<h3 class="fn"><a name="dataChanged"></a>void QOrganizerManagerEngine::dataChanged ()<tt> [signal]</tt></h3>
<p>This signal is emitted some time after changes occur to the data managed by this engine, and the engine is unable to determine which changes occurred, or if the engine considers the changes to be radical enough to require clients to reload all data.</p>
<p>If this signal is emitted, no other signals may be emitted for the associated changes.</p>
<p>As it is possible that other processes (or other devices) may have caused the changes, the timing can not be determined.</p>
<p>See also <a href="qorganizermanagerengine.html#itemsAdded">itemsAdded</a>(), <a href="qorganizermanagerengine.html#itemsChanged">itemsChanged</a>(), and <a href="qorganizermanagerengine.html#itemsRemoved">itemsRemoved</a>().</p>
<!-- @@@dataChanged -->
<!-- $$$defaultCollection[overload1]$$$defaultCollectionQOrganizerManager::Error* -->
<h3 class="fn"><a name="defaultCollection"></a><a href="qorganizercollection.html">QOrganizerCollection</a> QOrganizerManagerEngine::defaultCollection ( <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the default collection of the manager. Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@defaultCollection -->
<!-- $$$detailDefinition[overload1]$$$detailDefinitionconstQString&constQString&QOrganizerManager::Error* -->
<h3 class="fn"><a name="detailDefinition"></a><a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a> QOrganizerManagerEngine::detailDefinition ( const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>definitionName</i>, const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>organizeritemType</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the definition identified by the given <i>definitionName</i> that is valid for organizer items whose type is of the given <i>organizeritemType</i> in this store, or a default-constructed <a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a> if no such definition exists</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@detailDefinition -->
<!-- $$$detailDefinitions[overload1]$$$detailDefinitionsconstQString&QOrganizerManager::Error* -->
<h3 class="fn"><a name="detailDefinitions"></a><a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;<a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a>, <a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a>&gt; QOrganizerManagerEngine::detailDefinitions ( const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>organizeritemType</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the registered detail definitions which are valid for organizer items whose type is of the given <i>organizeritemType</i> in this engine.</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@detailDefinitions -->
<!-- $$$engineCollectionId[overload1]$$$engineCollectionIdconstQOrganizerCollectionId& -->
<h3 class="fn"><a name="engineCollectionId"></a>const <a href="qorganizercollectionid.html">QOrganizerCollectionEngineId</a> * QOrganizerManagerEngine::engineCollectionId ( const <a href="qorganizercollectionid.html">QOrganizerCollectionId</a> &amp; <i>id</i> )<tt> [static]</tt></h3>
<p>Returns the engine id from the given <i>id</i>. The caller does not take ownership of the pointer, and should not delete returned id or undefined behavior may occur.</p>
<!-- @@@engineCollectionId -->
<!-- $$$engineItemId[overload1]$$$engineItemIdconstQOrganizerItemId& -->
<h3 class="fn"><a name="engineItemId"></a>const <a href="qorganizeritemid.html">QOrganizerItemEngineId</a> * QOrganizerManagerEngine::engineItemId ( const <a href="qorganizeritemid.html">QOrganizerItemId</a> &amp; <i>id</i> )<tt> [static]</tt></h3>
<p>Returns the engine id from the given <i>id</i>. The caller does not take ownership of the pointer, and should not delete returned id or undefined behavior may occur.</p>
<!-- @@@engineItemId -->
<!-- $$$hasFeature[overload1]$$$hasFeatureQOrganizerManager::ManagerFeatureconstQString& -->
<h3 class="fn"><a name="hasFeature"></a>bool QOrganizerManagerEngine::hasFeature ( <a href="qorganizermanager.html#ManagerFeature-enum">QOrganizerManager::ManagerFeature</a> <i>feature</i>, const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>organizeritemType</i> ) const<tt> [virtual]</tt></h3>
<p>Returns true if the given <i>feature</i> is supported by this engine for organizer items of the given <i>organizeritemType</i></p>
<!-- @@@hasFeature -->
<!-- $$$isFilterSupported[overload1]$$$isFilterSupportedconstQOrganizerItemFilter& -->
<h3 class="fn"><a name="isFilterSupported"></a>bool QOrganizerManagerEngine::isFilterSupported ( const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> &amp; <i>filter</i> ) const<tt> [virtual]</tt></h3>
<p>Returns a whether the supplied <i>filter</i> can be implemented natively by this engine. If not, the base class implementation will emulate the functionality.</p>
<!-- @@@isFilterSupported -->
<!-- $$$isItemBetweenDates[overload1]$$$isItemBetweenDatesconstQOrganizerItem&constQDateTime&constQDateTime& -->
<h3 class="fn"><a name="isItemBetweenDates"></a>bool QOrganizerManagerEngine::isItemBetweenDates ( const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>item</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>startPeriod</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>endPeriod</i> )<tt> [static]</tt></h3>
<p>Returns true if the given <i>item</i> (or an occurrence of the item) occurs within the range specified by the <i>startPeriod</i> and the <i>endPeriod</i>, inclusive. A default-constructed <i>startPeriod</i> signifies that the lower bound of the range is infinitely small (i.e&#x2e;, will match anything up to the <i>endPeriod</i>) and a default-constructed <i>endPeriod</i> signifies that the upper bound of the range is infinitely large (i.e&#x2e;, will match anything which occurs after the <i>startPeriod</i>).</p>
<!-- @@@isItemBetweenDates -->
<!-- $$$item[overload1]$$$itemconstQOrganizerItemId&constQOrganizerItemFetchHint&QOrganizerManager::Error* -->
<h3 class="fn"><a name="item"></a><a href="qorganizeritem.html">QOrganizerItem</a> QOrganizerManagerEngine::item ( const <a href="qorganizeritemid.html">QOrganizerItemId</a> &amp; <i>organizeritemId</i>, const <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a> &amp; <i>fetchHint</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the organizer item in the database identified by <i>organizeritemId</i>.</p>
<p>If the item does not exist, an empty, default constructed <a href="qorganizeritem.html">QOrganizerItem</a> will be returned, and the <i>error</i> will be set to <tt>QOrganizerManager::DoesNotExistError</tt>.</p>
<p>Any operation error which occurs will be saved in <i>error</i>.</p>
<p>The <i>fetchHint</i> parameter describes the optimization hints that a manager may take. If the <i>fetchHint</i> is the default constructed hint, all existing details in the matching organizer items will be returned.</p>
<p>See also <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a>.</p>
<!-- @@@item -->
<!-- $$$itemIds[overload1]$$$itemIdsconstQDateTime&constQDateTime&constQOrganizerItemFilter&constQList<QOrganizerItemSortOrder>&QOrganizerManager::Error* -->
<h3 class="fn"><a name="itemIds"></a><a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemid.html">QOrganizerItemId</a>&gt; QOrganizerManagerEngine::itemIds ( const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>startDate</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>endDate</i>, const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> &amp; <i>filter</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a>&gt; &amp; <i>sortOrders</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns a list of organizer item ids that match the given <i>filter</i>, sorted according to the given list of <i>sortOrders</i>, for any item which occurs (or has an occurrence which occurs) in the range specified by the given <i>startDate</i> and <i>endDate</i>. A default-constructed (invalid) <i>startDate</i> specifies an open start date (matches anything which occurs up until the <i>endDate</i>), and a default-constructed (invalid) <i>endDate</i> specifies an open end date (matches anything which occurs after the <i>startDate</i>). If both the <i>startDate</i> and <i>endDate</i> are invalid, this function will return the ids of all items which match the <i>filter</i> criteria.</p>
<p>Depending on the backend, this filtering operation may involve retrieving all the organizer items. Any error which occurs will be saved in <i>error</i>.</p>
<!-- @@@itemIds -->
<!-- $$$itemLessThan[overload1]$$$itemLessThanconstQOrganizerItem&constQOrganizerItem& -->
<h3 class="fn"><a name="itemLessThan"></a>bool QOrganizerManagerEngine::itemLessThan ( const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>a</i>, const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>b</i> )<tt> [static]</tt></h3>
<p>Returns true if and only if <i>a</i> is temporally less than <i>b</i>. Items with an earlier date are temporally less than items with a later date, or items with no date. All day items are temporally less than non-all day items on the same date. For events and todos, the start date is used, or if null, the end date is used. This function defines a total ordering suitable for use in a sort function.</p>
<!-- @@@itemLessThan -->
<!-- $$$itemOccurrences[overload1]$$$itemOccurrencesconstQOrganizerItem&constQDateTime&constQDateTime&intconstQOrganizerItemFetchHint&QOrganizerManager::Error* -->
<h3 class="fn"><a name="itemOccurrences"></a><a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; QOrganizerManagerEngine::itemOccurrences ( const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>parentItem</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>periodStart</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>periodEnd</i>, int <i>maxCount</i>, const <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a> &amp; <i>fetchHint</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Return the list of a maximum of <i>maxCount</i> organizer item instances which are occurrences of the given <i>parentItem</i> recurring item, which occur between the given <i>periodStart</i> date and the given <i>periodEnd</i> date.</p>
<p>If <i>periodStart</i> is after <i>periodEnd</i>, the operation will fail, and <i>error</i> will be set to <tt>QOrganizerManager::BadArgumentError</tt>. If <i>maxCount</i> is negative, it is backend specific as to how many occurrences will be returned. Some backends may return no instances, others may return some limited number of occurrences.</p>
<p>If the <i>parentItem</i> is an item of type <a href="qorganizeritemtype.html#TypeEvent-var">QOrganizerItemType::TypeEvent</a>, a list of items of type <a href="qorganizeritemtype.html#TypeEventOccurrence-var">QOrganizerItemType::TypeEventOccurrence</a> will be returned, representing the expansion of the parent item according to its <a href="qorganizeritemrecurrence.html">QOrganizerItemRecurrence</a> detail. Similarly, a <i>parentItem</i> of type <a href="qorganizeritemtype.html#TypeTodo-var">QOrganizerItemType::TypeTodo</a> will result in a list of <a href="qorganizeritemtype.html#TypeTodoOccurrence-var">QOrganizerItemType::TypeTodoOccurrence</a> items. If the <i>parentItem</i> is of any other type, it is returned by itself from the backend.</p>
<p>The occurrence-typed items returned should have a <a href="qorganizeritemparent.html">QOrganizerItemParent</a> detail that refers to the parent item and the original instance that the event would have occurred on (if it is an exception). No returned item should contain a <a href="qorganizeritemrecurrence.html">QOrganizerItemRecurrence</a> detail.</p>
<p>If the <i>parentItem</i> does not exist in the backend, or if there are no instances matching the criteria, an empty list should be returned.</p>
<p>The <i>fetchHint</i> parameter is a hint to the manager about which details the client is interested in. It allows the manager to optimize retrieval of occurrences. The manager may ignore the <i>fetchHint</i>, but if it does so each item occurrence it returns must include all of the details associated with it in the database.</p>
<!-- @@@itemOccurrences -->
<!-- $$$items[overload1]$$$itemsconstQDateTime&constQDateTime&constQOrganizerItemFilter&constQList<QOrganizerItemSortOrder>&constQOrganizerItemFetchHint&QOrganizerManager::Error* -->
<h3 class="fn"><a name="items"></a><a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; QOrganizerManagerEngine::items ( const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>startDate</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>endDate</i>, const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> &amp; <i>filter</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a>&gt; &amp; <i>sortOrders</i>, const <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a> &amp; <i>fetchHint</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the list of organizer items which match the given <i>filter</i> stored in the manager sorted according to the given list of <i>sortOrders</i>, for any item or item occurrence which occurs in the range specified by the given <i>startDate</i> and <i>endDate</i>. A default-constructed (invalid) <i>startDate</i> specifies an open start date (matches anything which occurs up until the <i>endDate</i>), and a default-constructed (invalid) <i>endDate</i> specifies an open end date (matches anything which occurs after the <i>startDate</i>). If both the <i>startDate</i> and <i>endDate</i> are invalid, this function will return all items which match the <i>filter</i> criteria.</p>
<p>Any operation error which occurs will be saved in <i>error</i>.</p>
<p>The <i>fetchHint</i> parameter describes the optimization hints that a manager may take. If the <i>fetchHint</i> is the default constructed hint, all existing details in the matching organizer items will be returned.</p>
<p>See also <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a>.</p>
<!-- @@@items -->
<!-- $$$itemsAdded[overload1]$$$itemsAddedconstQList<QOrganizerItemId>& -->
<h3 class="fn"><a name="itemsAdded"></a>void QOrganizerManagerEngine::itemsAdded ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemid.html">QOrganizerItemId</a>&gt; &amp; <i>organizeritemIds</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted some time after a set of organizer items has been added to this engine where the <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>() signal was not emitted for those changes. As it is possible that other processes (or other devices) may have added the organizer items, the timing cannot be determined.</p>
<p>The list of ids of organizer items added is given by <i>organizeritemIds</i>. There may be one or more ids in the list.</p>
<p>See also <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>().</p>
<!-- @@@itemsAdded -->
<!-- $$$itemsChanged[overload1]$$$itemsChangedconstQList<QOrganizerItemId>& -->
<h3 class="fn"><a name="itemsChanged"></a>void QOrganizerManagerEngine::itemsChanged ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemid.html">QOrganizerItemId</a>&gt; &amp; <i>organizeritemIds</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted some time after a set of organizer items has been modified in this engine where the <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>() signal was not emitted for those changes. As it is possible that other processes (or other devices) may have modified the organizer items, the timing cannot be determined.</p>
<p>The list of ids of changed organizer items is given by <i>organizeritemIds</i>. There may be one or more ids in the list.</p>
<p>See also <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>().</p>
<!-- @@@itemsChanged -->
<!-- $$$itemsForExport[overload1]$$$itemsForExportconstQDateTime&constQDateTime&constQOrganizerItemFilter&constQList<QOrganizerItemSortOrder>&constQOrganizerItemFetchHint&QOrganizerManager::Error* -->
<h3 class="fn"><a name="itemsForExport"></a><a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; QOrganizerManagerEngine::itemsForExport ( const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>startDate</i>, const <a href="http://qt.nokia.com/doc/4.7/qdatetime.html">QDateTime</a> &amp; <i>endDate</i>, const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> &amp; <i>filter</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a>&gt; &amp; <i>sortOrders</i>, const <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a> &amp; <i>fetchHint</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns the list of organizer items which match the given <i>filter</i> stored in the manager sorted according to the given list of <i>sortOrders</i>, for any persisted item which occurs (or has an occurrence which occurs) in the range specified by the given <i>startDate</i> and <i>endDate</i>. A default-constructed (invalid) <i>startDate</i> specifies an open start date (matches anything which occurs up until the <i>endDate</i>), and a default-constructed (invalid) <i>endDate</i> specifies an open end date (matches anything which occurs after the <i>startDate</i>). If both the <i>startDate</i> and <i>endDate</i> are invalid, this function will return all items which match the <i>filter</i> criteria.</p>
<p>Any operation error which occurs will be saved in <i>error</i>.</p>
<p>The <i>fetchHint</i> parameter describes the optimization hints that a manager may take. If the <i>fetchHint</i> is the default constructed hint, all existing details in the matching organizer items will be returned.</p>
<p>Items of type <a href="qml-eventoccurrence.html">EventOccurrence</a> and <a href="qml-todooccurrence.html">TodoOccurrence</a> should only be returned when they represent an exceptional occurrence; ie. if the client has specifically saved the item occurrence in the manager. Occurrence-typed items that are generated purely from a recurrence specification of another detail should not be returned in this list.</p>
<p>All items returned should have a non-zero ID.</p>
<p>See also <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a>.</p>
<!-- @@@itemsForExport -->
<!-- $$$itemsRemoved[overload1]$$$itemsRemovedconstQList<QOrganizerItemId>& -->
<h3 class="fn"><a name="itemsRemoved"></a>void QOrganizerManagerEngine::itemsRemoved ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemid.html">QOrganizerItemId</a>&gt; &amp; <i>organizeritemIds</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted some time after a set of organizer items has been removed from this engine where the <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>() signal was not emitted for those changes. As it is possible that other processes (or other devices) may have removed the organizer items, the timing cannot be determined.</p>
<p>The list of ids of removed organizer items is given by <i>organizeritemIds</i>. There may be one or more ids in the list.</p>
<p>See also <a href="qorganizermanagerengine.html#dataChanged">dataChanged</a>().</p>
<!-- @@@itemsRemoved -->
<!-- $$$managerName[overload1]$$$managerName -->
<h3 class="fn"><a name="managerName"></a><a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> QOrganizerManagerEngine::managerName () const<tt> [pure virtual]</tt></h3>
<p>Returns the manager name for this <a href="qorganizermanagerengine.html">QOrganizerManagerEngine</a></p>
<!-- @@@managerName -->
<!-- $$$managerParameters[overload1]$$$managerParameters -->
<h3 class="fn"><a name="managerParameters"></a><a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;<a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a>, <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a>&gt; QOrganizerManagerEngine::managerParameters () const<tt> [virtual]</tt></h3>
<p>Returns the parameters with which this engine was constructed. Note that the engine may have discarded unused or invalid parameters at the time of construction, and these will not be returned.</p>
<!-- @@@managerParameters -->
<!-- $$$managerUri[overload1]$$$managerUri -->
<h3 class="fn"><a name="managerUri"></a><a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> QOrganizerManagerEngine::managerUri () const</h3>
<p>Returns the unique URI of this manager, which is built from the manager name and the parameters used to construct it.</p>
<!-- @@@managerUri -->
<!-- $$$managerVersion[overload1]$$$managerVersion -->
<h3 class="fn"><a name="managerVersion"></a>int QOrganizerManagerEngine::managerVersion () const<tt> [pure virtual]</tt></h3>
<p>Returns the engine backend implementation version number</p>
<!-- @@@managerVersion -->
<!-- $$$removeCollection[overload1]$$$removeCollectionconstQOrganizerCollectionId&QOrganizerManager::Error* -->
<h3 class="fn"><a name="removeCollection"></a>bool QOrganizerManagerEngine::removeCollection ( const <a href="qorganizercollectionid.html">QOrganizerCollectionId</a> &amp; <i>collectionId</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Returns true if the removing of the <i>collectionId</i> was successfull otherwise false. Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@removeCollection -->
<!-- $$$removeDetailDefinition[overload1]$$$removeDetailDefinitionconstQString&constQString&QOrganizerManager::Error* -->
<h3 class="fn"><a name="removeDetailDefinition"></a>bool QOrganizerManagerEngine::removeDetailDefinition ( const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>definitionName</i>, const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>organizeritemType</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Removes the definition identified by the given <i>definitionName</i> from the database, where it was valid for organizer items whose type was the given <i>organizeritemType</i>.</p>
<p>Returns true if the definition was removed successfully, otherwise returns false.</p>
<p>The backend must emit the appropriate signals to inform clients of changes to the database resulting from this operation.</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@removeDetailDefinition -->
<!-- $$$removeItem[overload1]$$$removeItemconstQOrganizerItemId&QOrganizerManager::Error* -->
<h3 class="fn"><a name="removeItem"></a>bool QOrganizerManagerEngine::removeItem ( const <a href="qorganizeritemid.html">QOrganizerItemId</a> &amp; <i>organizeritemId</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Remove the item identified by <i>organizeritemId</i> from the database. Returns true if the item was removed successfully, otherwise returns false.</p>
<p>Any error which occurs will be saved in <i>error</i>.</p>
<p>The default implementation will convert this into a call to removeItems.</p>
<!-- @@@removeItem -->
<!-- $$$removeItems[overload1]$$$removeItemsconstQList<QOrganizerItemId>&QMap<int,QOrganizerManager::Error>*QOrganizerManager::Error* -->
<h3 class="fn"><a name="removeItems"></a>bool QOrganizerManagerEngine::removeItems ( const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemid.html">QOrganizerItemId</a>&gt; &amp; <i>organizeritemIds</i>, <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; * <i>errorMap</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Remove every item whose id is contained in the list of organizer items ids <i>organizeritemIds</i>. Returns true if all organizer items were removed successfully, otherwise false.</p>
<p>The manager might populate <i>errorMap</i> (the map of indices of the <i>organizeritemIds</i> list to the error which occurred when saving the item at that index) for every index for which the item could not be removed, if it is able. The <a href="qorganizermanager.html#error">QOrganizerManager::error</a>() function will only return <tt>QOrganizerManager::NoError</tt> if all organizer items were removed successfully.</p>
<p>If the list contains ids which do not identify a valid item in the manager, the function will remove any organizer items which are identified by ids in the <i>organizeritemIds</i> list, insert <tt>QOrganizerManager::DoesNotExist</tt> entries into the <i>errorMap</i> for the indices of invalid ids in the <i>organizeritemIds</i> list, return false, and set the overall operation error to <tt>QOrganizerManager::DoesNotExistError</tt>.</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<p>See also <a href="qorganizermanager.html#removeItem">QOrganizerManager::removeItem</a>().</p>
<!-- @@@removeItems -->
<!-- $$$requestDestroyed[overload1]$$$requestDestroyedQOrganizerAbstractRequest* -->
<h3 class="fn"><a name="requestDestroyed"></a>void QOrganizerManagerEngine::requestDestroyed ( <a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a> * <i>req</i> )<tt> [virtual]</tt></h3>
<p>Notifies the manager engine that the given request <i>req</i> has been destroyed.</p>
<p>This notifies the engine that:</p>
<ul>
<li>the client doesn't care about the request any more. The engine can still complete it, but completion is not required.</li>
<li>it can't reliably access any properties of the request pointer any more. The pointer will be invalid once this function returns.</li>
</ul>
<p>This means that if there is a worker thread, the engine needs to let that thread know that the request object is not valid and block until that thread acknowledges it. One way to do this is to have a <a href="http://qt.nokia.com/doc/4.7/qset.html">QSet</a>&lt;<a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a>*&gt; (or <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;<a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a>, MyCustomRequestState&gt;) that tracks active requests, and insert into that set in startRequest, and remove in requestDestroyed (or when it finishes or is cancelled). Protect that set/map with a mutex, and make sure you take the mutex in the worker thread before calling any of the QOrganizerAbstractRequest::updateXXXXXXRequest functions. And be careful of lock ordering problems :D</p>
<!-- @@@requestDestroyed -->
<!-- $$$saveCollection[overload1]$$$saveCollectionQOrganizerCollection*QOrganizerManager::Error* -->
<h3 class="fn"><a name="saveCollection"></a>bool QOrganizerManagerEngine::saveCollection ( <a href="qorganizercollection.html">QOrganizerCollection</a> * <i>collection</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Returns true if the saving of the <i>collection</i> was successfull otherwise false. Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@saveCollection -->
<!-- $$$saveDetailDefinition[overload1]$$$saveDetailDefinitionconstQOrganizerItemDetailDefinition&constQString&QOrganizerManager::Error* -->
<h3 class="fn"><a name="saveDetailDefinition"></a>bool QOrganizerManagerEngine::saveDetailDefinition ( const <a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a> &amp; <i>def</i>, const <a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a> &amp; <i>organizeritemType</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Persists the given definition <i>def</i> in the database, which is valid for organizer items whose type is the given <i>organizeritemType</i>.</p>
<p>Returns true if the definition was saved successfully, and otherwise returns false.</p>
<p>The backend must emit the appropriate signals to inform clients of changes to the database resulting from this operation.</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@saveDetailDefinition -->
<!-- $$$saveItem[overload1]$$$saveItemQOrganizerItem*QOrganizerManager::Error* -->
<h3 class="fn"><a name="saveItem"></a>bool QOrganizerManagerEngine::saveItem ( <a href="qorganizeritem.html">QOrganizerItem</a> * <i>item</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Adds the given <i>item</i> to the database if <i>item</i> has a default-constructed id, or an id with the manager URI set to the URI of this manager and a id of zero, otherwise updates the organizer item in the database which has the same id to be the given <i>item</i>. If the id is non-zero but does not identify any item stored in the manager, the function will return false and <i>error</i> will be set to <tt>QOrganizerManager::DoesNotExistError</tt>.</p>
<p>The <i>item</i> will be added to the collection identified by the collectionId specified in the item (accessible via item-&gt;organizerId()) if it exists, and the item conforms to the schema supported for that collection. If the collection exists but the item does not conform to the schema supported for that collection, the function will return false, and the <i>error</i> will be set to <a href="qorganizermanager.html#Error-enum">QOrganizerManager::InvalidDetailError</a>.</p>
<p>If the collectionId is not the default (zero) id, but does not identify a valid collection, the function will return false, and <i>error</i> will be set to <a href="qorganizermanager.html#Error-enum">QOrganizerManager::InvalidCollectionError</a>. If the collectionId is the default (zero) id, the item should be saved in the collection in which it is already saved (if it is already saved in this manager), or in the default collection (if it is a new item in this manager).</p>
<p>Returns true if the save operation completed successfully, otherwise returns false. Any error which occurs will be saved in <i>error</i>.</p>
<p>The default implementation will convert this into a call to saveItems.</p>
<p>See also <a href="qorganizermanagerengine.html#managerUri">managerUri</a>().</p>
<!-- @@@saveItem -->
<!-- $$$saveItems[overload1]$$$saveItemsQList<QOrganizerItem>*QMap<int,QOrganizerManager::Error>*QOrganizerManager::Error* -->
<h3 class="fn"><a name="saveItems"></a>bool QOrganizerManagerEngine::saveItems ( <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; * <i>items</i>, <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; * <i>errorMap</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> )<tt> [virtual]</tt></h3>
<p>Adds the list of organizer items given by <i>items</i> list to the database. Returns true if the organizer items were saved successfully, otherwise false.</p>
<p>The engine might populate <i>errorMap</i> (the map of indices of the <i>items</i> list to the error which occurred when saving the item at that index) for every index for which the item could not be saved, if it is able. The <a href="qorganizermanager.html#error">QOrganizerManager::error</a>() function will only return <tt>QOrganizerManager::NoError</tt> if all organizer items were saved successfully.</p>
<p>For each newly saved item that was successful, the id of the item in the <i>items</i> list will be updated with the new value.</p>
<p>Each item in the given list <i>items</i> will be added to the collection identified in the item (accessible via item-&gt;collectionId()) if it exists, and if the item conform to the schema supported for that collection. If the collection exists but the item does not conform to the schema supported for that collection, the function will return false, and the error in the <i>errorMap</i> for the item at that index will be set to <a href="qorganizermanager.html#Error-enum">QOrganizerManager::InvalidDetailError</a>.</p>
<p>If the collectionId is not the default (zero) id, but does not identify a valid collection, the function will return false, and <i>error</i> will be set to <a href="qorganizermanager.html#Error-enum">QOrganizerManager::InvalidCollectionError</a>. If the collectionId is the default (zero) id, the item should be saved in the collection in which it is already saved (if they are already saved in this manager), or in the default collection (if they are new items in this manager).</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<p>See also <a href="qorganizermanager.html#saveItem">QOrganizerManager::saveItem</a>().</p>
<!-- @@@saveItems -->
<!-- $$$schemaDefinitions[overload1]$$$schemaDefinitionsint -->
<h3 class="fn"><a name="schemaDefinitions"></a><a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;<a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a>, <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;<a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a>, <a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a>&gt; &gt; QOrganizerManagerEngine::schemaDefinitions ( int <i>version</i> = 1 )<tt> [static]</tt></h3>
<p>Returns the default schema definitions for the given <i>version</i> of the schema. Version 1 of the schema corresponds to version 1.1 of the Qt Mobility APIs.</p>
<!-- @@@schemaDefinitions -->
<!-- $$$setDetailAccessConstraints[overload1]$$$setDetailAccessConstraintsQOrganizerItemDetail*QOrganizerItemDetail::AccessConstraints -->
<h3 class="fn"><a name="setDetailAccessConstraints"></a>void QOrganizerManagerEngine::setDetailAccessConstraints ( <a href="qorganizeritemdetail.html">QOrganizerItemDetail</a> * <i>detail</i>, <a href="qorganizeritemdetail.html#AccessConstraint-enum">QOrganizerItemDetail::AccessConstraints</a> <i>constraints</i> )<tt> [static]</tt></h3>
<p>Sets the access constraints of <i>detail</i> to the supplied <i>constraints</i>.</p>
<p>This function is provided to allow engine implementations to report the access constraints of retrieved details, without generally allowing the access constraints to be modified after retrieval.</p>
<p>Application code should not call this function, since validation of the detail will happen in the engine in any case.</p>
<!-- @@@setDetailAccessConstraints -->
<!-- $$$startRequest[overload1]$$$startRequestQOrganizerAbstractRequest* -->
<h3 class="fn"><a name="startRequest"></a>bool QOrganizerManagerEngine::startRequest ( <a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a> * <i>req</i> )<tt> [virtual]</tt></h3>
<p>Asks the manager engine to begin the given request <i>req</i> which is currently in a (re)startable state. Returns true if the request was started successfully, else returns false.</p>
<p>Generally, the engine queues the request and processes it at some later time (probably in another thread).</p>
<p>Once a request is started, the engine should call the updateRequestState and/or the specific updateXXXXXRequest functions to mark it in the active state.</p>
<p>If the engine is particularly fast, or the operation involves only in memory data, the request can be processed and completed without queueing it.</p>
<p>Note that when the client is threaded, and the request might live on a different thread, the engine needs to be careful with locking. In particular, the request might be deleted while the engine is still working on it. In this case, the requestDestroyed function will be called while the request is still valid, and that function should block until the worker thread (etc.) has been notified not to touch that request any more.</p>
<p>See also <a href="qorganizerabstractrequest.html#start">QOrganizerAbstractRequest::start</a>().</p>
<!-- @@@startRequest -->
<!-- $$$supportedItemTypes[overload1]$$$supportedItemTypes -->
<h3 class="fn"><a name="supportedItemTypes"></a><a href="http://qt.nokia.com/doc/4.7/qstringlist.html">QStringList</a> QOrganizerManagerEngine::supportedItemTypes () const<tt> [virtual]</tt></h3>
<p>Returns the list of item types which are supported by this engine. This is a convenience function, equivalent to retrieving the allowable values for the <tt>QOrganizerItemType::FieldType</tt> field of the <a href="qorganizeritemtype.html">QOrganizerItemType</a> definition which is valid in this engine.</p>
<!-- @@@supportedItemTypes -->
<!-- $$$testFilter[overload1]$$$testFilterconstQOrganizerItemFilter&constQOrganizerItem& -->
<h3 class="fn"><a name="testFilter"></a>bool QOrganizerManagerEngine::testFilter ( const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> &amp; <i>filter</i>, const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>item</i> )<tt> [static]</tt></h3>
<p>Returns true if the supplied item <i>item</i> matches the supplied filter <i>filter</i>.</p>
<p>This function will test each condition in the filter, possibly recursing.</p>
<!-- @@@testFilter -->
<!-- $$$updateCollectionFetchRequest[overload1]$$$updateCollectionFetchRequestQOrganizerCollectionFetchRequest*constQList<QOrganizerCollection>&QOrganizerManager::ErrorQOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateCollectionFetchRequest"></a>void QOrganizerManagerEngine::updateCollectionFetchRequest ( <a href="qorganizercollectionfetchrequest.html">QOrganizerCollectionFetchRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizercollection.html">QOrganizerCollection</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizercollectionfetchrequest.html">QOrganizerCollectionFetchRequest</a> <i>req</i> with the latest results <i>result</i>, operation error <i>error</i>, and a error map list <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress. If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateCollectionFetchRequest -->
<!-- $$$updateCollectionRemoveRequest[overload1]$$$updateCollectionRemoveRequestQOrganizerCollectionRemoveRequest*QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateCollectionRemoveRequest"></a>void QOrganizerManagerEngine::updateCollectionRemoveRequest ( <a href="qorganizercollectionremoverequest.html">QOrganizerCollectionRemoveRequest</a> * <i>req</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizercollectionremoverequest.html">QOrganizerCollectionRemoveRequest</a> <i>req</i> with the operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress. If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateCollectionRemoveRequest -->
<!-- $$$updateCollectionSaveRequest[overload1]$$$updateCollectionSaveRequestQOrganizerCollectionSaveRequest*constQList<QOrganizerCollection>&QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateCollectionSaveRequest"></a>void QOrganizerManagerEngine::updateCollectionSaveRequest ( <a href="qorganizercollectionsaverequest.html">QOrganizerCollectionSaveRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizercollection.html">QOrganizerCollection</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizercollectionsaverequest.html">QOrganizerCollectionSaveRequest</a> <i>req</i> with the latest results <i>result</i>, operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress. If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateCollectionSaveRequest -->
<!-- $$$updateDefinitionFetchRequest[overload1]$$$updateDefinitionFetchRequestQOrganizerItemDetailDefinitionFetchRequest*constQMap<QString,QOrganizerItemDetailDefinition>&QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateDefinitionFetchRequest"></a>void QOrganizerManagerEngine::updateDefinitionFetchRequest ( <a href="qorganizeritemdetaildefinitionfetchrequest.html">QOrganizerItemDetailDefinitionFetchRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;<a href="http://qt.nokia.com/doc/4.7/qstring.html">QString</a>, <a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemdetaildefinitionfetchrequest.html">QOrganizerItemDetailDefinitionFetchRequest</a> <i>req</i> with the latest results <i>result</i>, operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateDefinitionFetchRequest -->
<!-- $$$updateDefinitionRemoveRequest[overload1]$$$updateDefinitionRemoveRequestQOrganizerItemDetailDefinitionRemoveRequest*QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateDefinitionRemoveRequest"></a>void QOrganizerManagerEngine::updateDefinitionRemoveRequest ( <a href="qorganizeritemdetaildefinitionremoverequest.html">QOrganizerItemDetailDefinitionRemoveRequest</a> * <i>req</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemdetaildefinitionremoverequest.html">QOrganizerItemDetailDefinitionRemoveRequest</a> <i>req</i> with the operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateDefinitionRemoveRequest -->
<!-- $$$updateDefinitionSaveRequest[overload1]$$$updateDefinitionSaveRequestQOrganizerItemDetailDefinitionSaveRequest*constQList<QOrganizerItemDetailDefinition>&QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateDefinitionSaveRequest"></a>void QOrganizerManagerEngine::updateDefinitionSaveRequest ( <a href="qorganizeritemdetaildefinitionsaverequest.html">QOrganizerItemDetailDefinitionSaveRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemdetaildefinitionsaverequest.html">QOrganizerItemDetailDefinitionSaveRequest</a> <i>req</i> with the latest results <i>result</i>, operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateDefinitionSaveRequest -->
<!-- $$$updateItemFetchForExportRequest[overload1]$$$updateItemFetchForExportRequestQOrganizerItemFetchForExportRequest*constQList<QOrganizerItem>&QOrganizerManager::ErrorQOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateItemFetchForExportRequest"></a>void QOrganizerManagerEngine::updateItemFetchForExportRequest ( <a href="qorganizeritemfetchforexportrequest.html">QOrganizerItemFetchForExportRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemfetchforexportrequest.html">QOrganizerItemFetchForExportRequest</a> <i>req</i> with the latest results <i>result</i>, and operation error <i>error</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateItemFetchForExportRequest -->
<!-- $$$updateItemFetchRequest[overload1]$$$updateItemFetchRequestQOrganizerItemFetchRequest*constQList<QOrganizerItem>&QOrganizerManager::ErrorQOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateItemFetchRequest"></a>void QOrganizerManagerEngine::updateItemFetchRequest ( <a href="qorganizeritemfetchrequest.html">QOrganizerItemFetchRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemfetchrequest.html">QOrganizerItemFetchRequest</a> <i>req</i> with the latest results <i>result</i>, and operation error <i>error</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateItemFetchRequest -->
<!-- $$$updateItemIdFetchRequest[overload1]$$$updateItemIdFetchRequestQOrganizerItemIdFetchRequest*constQList<QOrganizerItemId>&QOrganizerManager::ErrorQOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateItemIdFetchRequest"></a>void QOrganizerManagerEngine::updateItemIdFetchRequest ( <a href="qorganizeritemidfetchrequest.html">QOrganizerItemIdFetchRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritemid.html">QOrganizerItemId</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemidfetchrequest.html">QOrganizerItemIdFetchRequest</a> <i>req</i> with the latest results <i>result</i>, and operation error <i>error</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateItemIdFetchRequest -->
<!-- $$$updateItemOccurrenceFetchRequest[overload1]$$$updateItemOccurrenceFetchRequestQOrganizerItemOccurrenceFetchRequest*constQList<QOrganizerItem>&QOrganizerManager::ErrorQOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateItemOccurrenceFetchRequest"></a>void QOrganizerManagerEngine::updateItemOccurrenceFetchRequest ( <a href="qorganizeritemoccurrencefetchrequest.html">QOrganizerItemOccurrenceFetchRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemoccurrencefetchrequest.html">QOrganizerItemOccurrenceFetchRequest</a> <i>req</i> with the latest results <i>result</i>, and operation error <i>error</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateItemOccurrenceFetchRequest -->
<!-- $$$updateItemRemoveRequest[overload1]$$$updateItemRemoveRequestQOrganizerItemRemoveRequest*QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateItemRemoveRequest"></a>void QOrganizerManagerEngine::updateItemRemoveRequest ( <a href="qorganizeritemremoverequest.html">QOrganizerItemRemoveRequest</a> * <i>req</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemremoverequest.html">QOrganizerItemRemoveRequest</a> <i>req</i> with the operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateItemRemoveRequest -->
<!-- $$$updateItemSaveRequest[overload1]$$$updateItemSaveRequestQOrganizerItemSaveRequest*constQList<QOrganizerItem>&QOrganizerManager::ErrorconstQMap<int,QOrganizerManager::Error>&QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateItemSaveRequest"></a>void QOrganizerManagerEngine::updateItemSaveRequest ( <a href="qorganizeritemsaverequest.html">QOrganizerItemSaveRequest</a> * <i>req</i>, const <a href="http://qt.nokia.com/doc/4.7/qlist.html">QList</a>&lt;<a href="qorganizeritem.html">QOrganizerItem</a>&gt; &amp; <i>result</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> <i>error</i>, const <a href="http://qt.nokia.com/doc/4.7/qmap.html">QMap</a>&lt;int, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a>&gt; &amp; <i>errorMap</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>newState</i> )<tt> [static]</tt></h3>
<p>Updates the given <a href="qorganizeritemsaverequest.html">QOrganizerItemSaveRequest</a> <i>req</i> with the latest results <i>result</i>, operation error <i>error</i>, and map of input index to individual error <i>errorMap</i>. In addition, the state of the request will be changed to <i>newState</i>.</p>
<p>It then causes the request to emit its resultsAvailable() signal to notify clients of the request progress.</p>
<p>If the new request state is different from the previous state, the stateChanged() signal will also be emitted from the request.</p>
<!-- @@@updateItemSaveRequest -->
<!-- $$$updateRequestState[overload1]$$$updateRequestStateQOrganizerAbstractRequest*QOrganizerAbstractRequest::State -->
<h3 class="fn"><a name="updateRequestState"></a>void QOrganizerManagerEngine::updateRequestState ( <a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a> * <i>req</i>, <a href="qorganizerabstractrequest.html#State-enum">QOrganizerAbstractRequest::State</a> <i>state</i> )<tt> [static]</tt></h3>
<p>Updates the given asynchronous request <i>req</i> by setting the new <i>state</i> of the request. If the new state is different, the stateChanged() signal will be emitted by the request.</p>
<!-- @@@updateRequestState -->
<!-- $$$validateCollection[overload1]$$$validateCollectionconstQOrganizerCollection&QOrganizerManager::Error* -->
<h3 class="fn"><a name="validateCollection"></a>bool QOrganizerManagerEngine::validateCollection ( const <a href="qorganizercollection.html">QOrganizerCollection</a> &amp; <i>collection</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Returns true if the <i>collection</i> is valid and can be saved in the engine. By default, modifiable collections are not supported, so this function returns false, and <i>error</i> is set to <a href="qorganizermanager.html#Error-enum">QOrganizerManager::NotSupportedError</a>. Engines which do implement mutable collections should reimplement this function.</p>
<!-- @@@validateCollection -->
<!-- $$$validateDefinition[overload1]$$$validateDefinitionconstQOrganizerItemDetailDefinition&QOrganizerManager::Error* -->
<h3 class="fn"><a name="validateDefinition"></a>bool QOrganizerManagerEngine::validateDefinition ( const <a href="qorganizeritemdetaildefinition.html">QOrganizerItemDetailDefinition</a> &amp; <i>definition</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Checks that the given detail definition <i>definition</i> seems valid, with a correct id, defined fields, and any specified value types are supported by this engine. This function is called before trying to save a definition.</p>
<p>Returns true if the <i>definition</i> seems valid, otherwise returns false.</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@validateDefinition -->
<!-- $$$validateItem[overload1]$$$validateItemconstQOrganizerItem&QOrganizerManager::Error* -->
<h3 class="fn"><a name="validateItem"></a>bool QOrganizerManagerEngine::validateItem ( const <a href="qorganizeritem.html">QOrganizerItem</a> &amp; <i>item</i>, <a href="qorganizermanager.html#Error-enum">QOrganizerManager::Error</a> * <i>error</i> ) const<tt> [virtual]</tt></h3>
<p>Checks that the given item <i>item</i> does not have details which don't conform to a valid definition, violate uniqueness constraints, or contain values for nonexistent fields, and that the values contained are of the correct type for each field, and are allowable values for that field.</p>
<p>Note that this function is unable to ensure that the access constraints (such as CreateOnly and ReadOnly) are observed; backend specific code must be written if you wish to enforce these constraints.</p>
<p>Returns true if the <i>item</i> is valid according to the definitions for its details, otherwise returns false.</p>
<p>Any errors encountered during this operation should be stored to <i>error</i>.</p>
<!-- @@@validateItem -->
<!-- $$$waitForRequestFinished[overload1]$$$waitForRequestFinishedQOrganizerAbstractRequest*int -->
<h3 class="fn"><a name="waitForRequestFinished"></a>bool QOrganizerManagerEngine::waitForRequestFinished ( <a href="qorganizerabstractrequest.html">QOrganizerAbstractRequest</a> * <i>req</i>, int <i>msecs</i> )<tt> [virtual]</tt></h3>
<p>Blocks until the manager engine has completed the given request <i>req</i> which was previously started, or until <i>msecs</i> milliseconds have passed. Returns true if the request was completed, and false if the request was not in the <tt>QOrganizerAbstractRequest::Active</tt> state or no progress could be reported.</p>
<p>It is important that this function is implemented by the engine, at least merely as a delay, since clients may call it in a loop.</p>
<p>See also <a href="qorganizermanagerengine.html#startRequest">startRequest</a>().</p>
<!-- @@@waitForRequestFinished -->
</div>
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
