<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- organizerengines.qdoc -->
  <title>Qt 1.2: Qt Organizer Manager Engines</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>QtMobility Reference Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
              <li>Qt Organizer Manager Engines</li>    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#information-for-engine-implementors">Information For Engine Implementors</a></li>
<li class="level2"><a href="#manager-engine">Manager Engine</a></li>
<li class="level2"><a href="#schemas">Schemas</a></li>
<li class="level2"><a href="#engine-specific-ids">Engine-Specific Ids</a></li>
<li class="level2"><a href="#which-functions-do-i-need-to-implement">Which Functions Do I Need To Implement</a></li>
<li class="level3"><a href="#mandatory-functions">Mandatory Functions</a></li>
<li class="level3"><a href="#optional-functionality">Optional Functionality</a></li>
<li class="level3"><a href="#optional-implementation">Optional Implementation</a></li>
<li class="level2"><a href="#which-signals-do-i-need-to-emit">Which Signals Do I Need To Emit</a></li>
<li class="level2"><a href="#other-considerations">Other Considerations</a></li>
<li class="level2"><a href="#example-implementation">Example Implementation</a></li>
</ul>
</div>
<h1 class="title">Qt Organizer Manager Engines</h1>
<span class="subtitle"></span>
<!-- $$$organizerengines.html-description -->
<div class="descr"> <a name="details"></a>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>The <a href="qorganizermanager.html">QOrganizerManager</a> interface provided to clients to allow access to organizer information depends on an implementation of <a href="qorganizermanagerengine.html">QOrganizerManagerEngine</a> existing. This engine provides the methods which are called by the manager. An engine is identified by its URI, which is the name reported to clients through the <a href="qorganizermanager.html#managerUri">QOrganizerManager::managerUri</a>() function. The URI of a manager is built by combining its name, version and relevant construction parameters.</p>
<a name="information-for-engine-implementors"></a>
<h2>Information For Engine Implementors</h2>
<p>Some developers may wish to provide implementations of <a href="qorganizermanagerengine.html">QOrganizerManagerEngine</a> for use by clients. The engine that they provide may aggregate multiple datastores, or access a remote datastore, or provide some other functionality to clients. An engine is distributed as a Qt Plugin, and will be detected automatically by the plugin loading code in the <a href="qorganizermanager.html">QOrganizerManager</a>, so long as the plugin is located in the correct path ($QT_PLUGINS_DIR/organizer/).</p>
<a name="manager-engine"></a>
<h3>Manager Engine</h3>
<p>The functionality exposed by the <a href="qorganizermanager.html">QOrganizerManager</a> class may be implemented by <a href="qorganizermanagerengine.html">engine</a> plugins which interface directly to a platform-specific backend or provide their own data storage backend. As such, the terms &quot;manager&quot;, &quot;plugin&quot; and &quot;backend&quot; are used interchangeably in this documentation to refer to any engine plugin which implements the functionality exposed by the <a href="qorganizermanager.html">QOrganizerManager</a> interface. The plugin architecture allows dynamic loading of different manager engines at runtime.</p>
<p>A manager backend may be implemented by subclassing <a href="qorganizermanagerengine.html">QOrganizerManagerEngine</a>, and providing a <a href="qorganizermanagerenginefactory.html">QOrganizerManagerEngineFactory</a> which can instantiate it when required.</p>
<a name="schemas"></a>
<h3>Schemas</h3>
<p>The schema supported by a engine is the list of detail definitions which are supported by the engine. For in-depth information about the schema, please refer to the main <a href="organizerschema.html">Qt Organizer Schema</a> page.</p>
<a name="engine-specific-ids"></a>
<h3>Engine-Specific Ids</h3>
<p>Each engine interfaces with a particular datastore, and that datastore may have its own particular way of identifying items stored in it. The QtMobility Organizer API allows engine implementers to define their own id format.</p>
<p>Engine implementers must implement their own id classes derived from <a href="qorganizeritemid.html">QOrganizerItemEngineId</a> and <a href="qorganizercollectionid.html">QOrganizerCollectionEngineId</a> respectively. For an example of how to implement these classes, see the &quot;skeleton&quot; example plugin.</p>
<a name="which-functions-do-i-need-to-implement"></a>
<h3>Which Functions Do I Need To Implement</h3>
<p>Different engines provide different functionality and support different features. Depending on the feature set of the engine, it will need to implement a particular subset of the API. The default implementation for most functions will set the error to <tt>QOrganizerManager::NotSupportedError</tt> and return the value which indicates that an error has occurred.</p>
<a name="mandatory-functions"></a>
<h4>Mandatory Functions</h4>
<p>All engines must implement the following functions:</p>
<ul>
<li><a href="qorganizermanagerengine.html#managerName">QOrganizerManagerEngine::managerName</a>()</li>
<li><a href="qorganizermanagerengine.html#managerVersion">QOrganizerManagerEngine::managerVersion</a>()</li>
<li><a href="qorganizermanagerengine.html#supportedItemTypes">QOrganizerManagerEngine::supportedItemTypes</a>()</li>
<li><a href="qorganizermanagerengine.html#hasFeature">QOrganizerManagerEngine::hasFeature</a>()</li>
<li><a href="qorganizermanagerengine.html#detailDefinitions">QOrganizerManagerEngine::detailDefinitions</a>()</li>
<li><a href="qorganizermanagerengine.html#itemIds">QOrganizerManagerEngine::itemIds</a>()</li>
<li><a href="qorganizermanagerengine.html#items">QOrganizerManagerEngine::items</a>()</li>
<li><a href="qorganizermanagerengine.html#itemsForExport">QOrganizerManagerEngine::itemsForExport</a>()</li>
<li><a href="qorganizermanagerengine.html#defaultCollection">QOrganizerManagerEngine::defaultCollection</a>()</li>
<li><a href="qorganizermanagerengine.html#collections">QOrganizerManagerEngine::collections</a>()</li>
</ul>
<p>Every engine implementation must also come with an implementation of <a href="qorganizermanagerenginefactory.html">QOrganizerManagerEngineFactory</a> for that engine.</p>
<p>Note that you do not need to implement filtering and sorting natively in an engine; the default implementation offers the following static functions to perform filtering and sorting respectively, in memory:</p>
<ul>
<li><a href="qorganizermanagerengine.html#testFilter">QOrganizerManagerEngine::testFilter</a>()</li>
<li>QOrganizerManagerEngine::sortItems()</li>
</ul>
<p>However, engine implementors should be aware that the default implementation is naive and will have greatly reduced performance compared to a native implementation (e.g&#x2e;, SQL queries, if the calendar or personal data exposed by the engine implementation is stored in an SQL database).</p>
<p>Similarly, any <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a> parameter may be ignored by an engine implementation, but if it does so it must return all information available for the item.</p>
<p>All engines must also implement the following functions to implement asynchronous requests:</p>
<ul>
<li><a href="qorganizermanagerengine.html#requestDestroyed">QOrganizerManagerEngine::requestDestroyed</a>()</li>
<li><a href="qorganizermanagerengine.html#startRequest">QOrganizerManagerEngine::startRequest</a>()</li>
<li><a href="qorganizermanagerengine.html#cancelRequest">QOrganizerManagerEngine::cancelRequest</a>()</li>
<li><a href="qorganizermanagerengine.html#waitForRequestFinished">QOrganizerManagerEngine::waitForRequestFinished</a>()</li>
</ul>
<p>If the engine does not support asynchronous requests, it should always return false in the last three of those functions, and do nothing in the first. If the engine does support asynchronous requests, it must ensure that all information required to perform the request is saved in the engine within <a href="qorganizermanagerengine.html#startRequest">QOrganizerManagerEngine::startRequest</a>(), as the client owns the request object and may delete it at any time. In general, engine implementors should be aware of this ownership semantic, and never attempt an unsafe operation on a request pointer.</p>
<p>It is recommended that all engine implementations support asynchronous requests, even if they use a &quot;dummy&quot; implementation which services the request synchronously during startRequest, and then emit the appropriate signals from the request via a zero-millisecond timeout timer.</p>
<a name="optional-functionality"></a>
<h4>Optional Functionality</h4>
<p>The rest of the virtual functions are optional, and should be implemented only if the engine supports the operations.</p>
<p>If the engine can be constructed with different parameters, which affects the operation of the engine (for example, a parameter might define which file to read schedule or calendar information from, or it might be an access token to prove that the client has the access rights to read organizer information from the engine, etc), it must report which parameters it was constructed with via the</p>
<ul>
<li><a href="qorganizermanagerengine.html#managerParameters">QOrganizerManagerEngine::managerParameters</a>()</li>
</ul>
<p>function.</p>
<p>If the engine supports native filtering of any kind, it must report to clients which filters are supported natively by implementing:</p>
<ul>
<li><a href="qorganizermanagerengine.html#isFilterSupported">QOrganizerManagerEngine::isFilterSupported</a>()</li>
</ul>
<p>If the engine supports saving or removing organizer item information, as well as retrieval, it must implement:</p>
<ul>
<li><a href="qorganizermanagerengine.html#saveItems">QOrganizerManagerEngine::saveItems</a>()</li>
<li><a href="qorganizermanagerengine.html#removeItems">QOrganizerManagerEngine::removeItems</a>()</li>
</ul>
<p>It may also choose to implement the &quot;single item&quot; functions:</p>
<ul>
<li><a href="qorganizermanagerengine.html#saveItem">QOrganizerManagerEngine::saveItem</a>()</li>
<li><a href="qorganizermanagerengine.html#removeItem">QOrganizerManagerEngine::removeItem</a>()</li>
</ul>
<p>If it does not, the default implementation of those functions will use the batch (plural) versions of those functions to implement the required behavior.</p>
<p>If the engine supports addition, modification and removal of collections, it must implement:</p>
<ul>
<li><a href="qorganizermanagerengine.html#saveCollection">QOrganizerManagerEngine::saveCollection</a>()</li>
<li><a href="qorganizermanagerengine.html#removeCollection">QOrganizerManagerEngine::removeCollection</a>()</li>
</ul>
<p>If the engine supports modification of its schema (that is, extension of its definitions at run-time), it must report that it supports the <tt>QOrganizerManager::MutableDefinitions</tt> feature via <a href="qorganizermanagerengine.html#hasFeature">QOrganizerManagerEngine::hasFeature</a>(), and must also implement:</p>
<ul>
<li><a href="qorganizermanagerengine.html#saveDetailDefinition">QOrganizerManagerEngine::saveDetailDefinition</a>()</li>
<li><a href="qorganizermanagerengine.html#removeDetailDefinition">QOrganizerManagerEngine::removeDetailDefinition</a>()</li>
</ul>
<a name="optional-implementation"></a>
<h4>Optional Implementation</h4>
<p>Apart from areas of functionality which may be optionally implemented by the engine or not, the default implementation provides several functions which operate in a naive, in-memory manner. An engine implementation can override this default implementation with its own, if it wishes, in order to obtain performance gains, or to more accurately implement the function.</p>
<p>As previously mentioned it may implement its own sorting or filtering, in functions such as <a href="qorganizermanagerengine.html#items">QOrganizerManagerEngine::items</a>(). An engine may also implement:</p>
<ul>
<li><a href="qorganizermanagerengine.html#validateItem">QOrganizerManagerEngine::validateItem</a>()</li>
<li><a href="qorganizermanagerengine.html#validateCollection">QOrganizerManagerEngine::validateCollection</a>()</li>
<li><a href="qorganizermanagerengine.html#validateDefinition">QOrganizerManagerEngine::validateDefinition</a>()</li>
<li><a href="qorganizermanagerengine.html#compatibleItem">QOrganizerManagerEngine::compatibleItem</a>()</li>
<li><a href="qorganizermanagerengine.html#compatibleCollection">QOrganizerManagerEngine::compatibleCollection</a>()</li>
</ul>
<a name="which-signals-do-i-need-to-emit"></a>
<h3>Which Signals Do I Need To Emit</h3>
<p>An engine implementation must emit the appropriate signals for the subset of functionality that it supports.</p>
<p>If the engine supports reading or saving items, it must emit the:</p>
<ul>
<li><a href="qorganizermanagerengine.html#itemsAdded">QOrganizerManagerEngine::itemsAdded</a>()</li>
<li><a href="qorganizermanagerengine.html#itemsChanged">QOrganizerManagerEngine::itemsChanged</a>()</li>
<li><a href="qorganizermanagerengine.html#itemsRemoved">QOrganizerManagerEngine::itemsRemoved</a>()</li>
</ul>
<p>signals as appropriate. Alternatively, it can emit the <a href="qorganizermanager.html#dataChanged">QOrganizerManager::dataChanged</a>() signal instead.</p>
<p>Similarly, if the engine supports reading or saving collections, it must emit the:</p>
<ul>
<li><a href="qorganizermanagerengine.html#collectionsAdded">QOrganizerManagerEngine::collectionsAdded</a>()</li>
<li><a href="qorganizermanagerengine.html#collectionsChanged">QOrganizerManagerEngine::collectionsChanged</a>()</li>
<li><a href="qorganizermanagerengine.html#collectionsRemoved">QOrganizerManagerEngine::collectionsRemoved</a>()</li>
</ul>
<p>signals as appropriate. Alternatively, it can emit the <a href="qorganizermanager.html#dataChanged">QOrganizerManager::dataChanged</a>() signal instead.</p>
<p>Note that the collectionsChanged() signal should be emitted if the meta data of a collection is updated, not if the client saves an item in the collection. That is, the collection-related signals are for collection meta-data, not the contents of the collection.</p>
<a name="other-considerations"></a>
<h3>Other Considerations</h3>
<p>There are several other considerations that engine writers must be aware of:</p>
<ul>
<li>Most batch functions take an error map as a parameter. This parameter cannot be null as it exists in the private implementation of <a href="qorganizermanager.html">QOrganizerManager</a>, so engines need not check the pointer before attempting to dereference it.</li>
<li>Every function takes a mandatory <tt>QOrganizerManager::Error</tt> pointer argument. This argument is also never null, since it exists in the private implementation of <a href="qorganizermanager.html">QOrganizerManager</a>. Testing this argument for null is, therefore, superfluous.</li>
<li>The single-item functions for item retrieval, removal and save already have a default implementation which merely wraps the batch retrieval, removal or save function appropriately. This default implementation may not be as performant as a hand-rolled function. Engine implementations MUST implement the batch functions for each area of functionality supported by the engine.</li>
<li>Most clients will prefer to use the asynchronous API to access information from the engine. It is therefore suggested that asynchronous requests be serviced, even if it is implemented in a similar manner to the (provided) memory engine's naive implementation.</li>
</ul>
<a name="example-implementation"></a>
<h3>Example Implementation</h3>
<p>There are several implementations of <a href="qorganizermanagerengine.html">QOrganizerManagerEngine</a> available in the QtMobility source code repository. In particular, the &quot;memory&quot; engine provides an implementation of an in-memory, anonymous datastore which supports almost every feature in the API, and therefore is useful for demonstration purposes. Be aware, however, that the implementation of all functionality in the &quot;memory&quot; engine is naive and not performant, and should not be copied in any real engine implementation (e.g&#x2e;, to perform filtering, it reads all items from the (in-memory) database, and checks one by one for matches; a real engine, on the other hand, might perform a database query to return the results directly, rather than performing n-reads).</p>
<p>The &quot;skeleton&quot; engine provides a useful template for engine implementors, and it is suggested that it is used as a starting point for anyone who wishes to implement a <a href="qorganizermanagerengine.html">QOrganizerManagerEngine</a>.</p>
</div>
<!-- @@@organizerengines.html -->
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
