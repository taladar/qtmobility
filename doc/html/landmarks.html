<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qlandmarks.qdoc -->
  <title>Qt 1.2: Landmark Examples</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>QtMobility Reference Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
              <li>Landmark Examples</li>    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#namespace">Namespace</a></li>
<li class="level1"><a href="#creating-saving-categories-and-landmarks">Creating/saving categories and landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level3"><a href="#creating-saving-a-category"><b>Creating/saving a category</b></a></li>
<li class="level3"><a href="#creating-saving-a-landmark"><b>Creating/saving a landmark</b></a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level3"><a href="#creating-saving-a-category"><b>Creating/saving a category</b></a></li>
<li class="level3"><a href="#creating-saving-a-landmark"><b>Creating/saving a landmark</b></a></li>
<li class="level1"><a href="#retrieving-categories-and-landmarks">Retrieving categories and landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level3"><a href="#retrieving-categories"><b>Retrieving categories</b></a></li>
<li class="level3"><a href="#retrieving-landmarks"><b>Retrieving landmarks</b></a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level3"><a href="#retrieving-categories"><b>Retrieving categories</b></a></li>
<li class="level3"><a href="#retrieving-landmarks"><b>Retrieving landmarks</b></a></li>
<li class="level1"><a href="#deleting-categories-and-landmarks">Deleting categories and landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level3"><a href="#deleting-a-category"><b>Deleting a category</b></a></li>
<li class="level3"><a href="#deleting-a-landmark"><b>Deleting a landmark</b></a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level3"><a href="#deleting-a-category"><b>Deleting a category</b></a></li>
<li class="level3"><a href="#deleting-a-landmark"><b>Deleting a landmark</b></a></li>
<li class="level1"><a href="#importing-landmarks">Importing Landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level1"><a href="#exporting-landmarks">Exporting Landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level1"><a href="#c-examples">C++ Examples</a></li>
<li class="level1"><a href="#qml-examples">QML Examples</a></li>
<li class="level2"><a href="#landmark-map-qml-example"><b>Landmark Map QML Example</b></a></li>
<li class="level2"><a href="#map-viewer-qml-example"><b>Map Viewer QML Example</b></a></li>
</ul>
</div>
<h1 class="title">Landmark Examples</h1>
<span class="subtitle"></span>
<!-- $$$landmarks.html-description -->
<div class="descr"> <a name="details"></a>
<p>The Landmarks portion of the Location API enables the creation, retrieval, updating and deletion of landmarks from arbitrary data stores. The following page demonstrates how to perform these operations.</p>
<a name="namespace"></a>
<h2>Namespace</h2>
<p>The QtMobility APIs are placed into the <i>QtMobility</i> namespace. This is done to facilitate the future migration of QtMobility APIs into Qt. See the <a href="quickstart.html">Quickstart guide</a> for an example on how the namespace impacts on application development.</p>
<a name="creating-saving-categories-and-landmarks"></a>
<h2>Creating/saving categories and landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<a name="creating-saving-a-category"></a>
<h4><b>Creating/saving a category</b></h4>
<p>The following example demonstrates how to synchronously add a category. We create a <a href="qlandmarkcategory.html">QLandmarkCategory</a> instance, set the desired properties and then use a <a href="qlandmarkmanager.html">QLandmarkManager</a> instance to save it. When the category is saved, it is assigned a <a href="qlandmarkcategoryid.html">QLandmarkCategoryId</a> which is why it passed as a pointer.</p>
<pre class="highlightedCode brush: cpp">     QLandmarkCategory cafes;
     cafes.setName(&quot;Cafes&quot;);
     cafes.setIconUrl(QUrl(&quot;cafe.png&quot;));
     lmManager-&gt;saveCategory(&amp;cafes);  <span class="comment">//lmManager is a QLandmarkManager *</span></pre>
<a name="creating-saving-a-landmark"></a>
<h4><b>Creating/saving a landmark</b></h4>
<p>The following example demonstrates synchronously adding a landmark. We create a <a href="qlandmark.html">QLandmark</a> instance, set the desired properties and then use a QLandmarkManger instance to save it. When the landmark is saved, it is assigned a <a href="qlandmarkid.html">QLandmarkId</a>, which is why it is passed as a pointer.</p>
<pre class="highlightedCode brush: cpp">     QLandmark monks;
     monks.setName(&quot;Monk's cafe&quot;);
     monks.setCoordinate(QGeoCoordinate(40.81, 73.97));

     QGeoAddress address;
     address.setStreet(&quot;2880 112th Street&quot;);
     address.setCity(&quot;New York City&quot;);
     address.setState(&quot;New York&quot;);
     address.setCountry(&quot;United States&quot;);
     address.setCountryCode(&quot;US&quot;);
     monks.setAddress(address);

     monks.setDescription(&quot;Jerry's favourite diner&quot;);
     monks.addCategoryId(cafes.categoryId());

     lmManager-&gt;saveLandmark(&amp;monks); <span class="comment">//lmManager  is a QLandmarkManager*</span></pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<a name="creating-saving-a-category"></a>
<h4><b>Creating/saving a category</b></h4>
<p>We create a <a href="qlandmarkcategory.html">QLandmarkCategory</a> instance and set the desired properties. Next we have an instance of a <a href="qlandmarkcategorysaverequest.html">QLandmarkCategorySaveRequest</a> and set the category we want to save. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categorySaveRequest()
 {
     QLandmarkCategory cafes;
     cafes.setName(&quot;Cafes&quot;);
     cafes.setIconUrl(QUrl(&quot;cafe.png&quot;));

     <span class="comment">//catSaveRequest was previously created with catSaveRequest = new QLandmarkCategorySaveRequest(lmManager)</span>
     <span class="comment">//where lmManager is a QLandmarkManager *</span>
     catSaveRequest-&gt;setCategory(cafes);

     connect(catSaveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(categorySaveRequestHandler(QLandmarkAbstractRequest::State)));
     if (!catSaveRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to save category, error code: &quot; &lt;&lt; catSaveRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Saveing category; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states or error codes. In our example we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and see if there are any errors or not. We may reuse the <a href="qlandmarkcategorysaverequest.html">QLandmarkCategorySaveRequest</a> by setting another category and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categorySaveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (catSaveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Category save successfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Category save was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="creating-saving-a-landmark"></a>
<h4><b>Creating/saving a landmark</b></h4>
<p>We create a <a href="qlandmark.html">QLandmark</a> instance and set the desired properties. Next we have an instance of a <a href="qlandmarksaverequest.html">QLandmarkSaveRequest</a> and set the landmark we want to save. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkSaveRequest()
 {
     <span class="comment">//Creating and saving a landmark</span>
     QLandmark monks;
     monks.setName(&quot;Monk's cafe&quot;);
     monks.setCoordinate(QGeoCoordinate(40.81, 73.97));

     QGeoAddress address;
     address.setStreet(&quot;2880 112th Street&quot;);
     <span class="comment">// ...</span>
     address.setCountryCode(&quot;US&quot;);
     monks.setAddress(address);
     monks.setDescription(&quot;Jerry's favourite diner&quot;);

     <span class="comment">//lmSaveRequest was previously created with lmSaveRequest = new QLandmarkSaveRequest(lmManager);</span>
     <span class="comment">//where lmManager is a QLandamrkManager *</span>
     lmSaveRequest-&gt;setLandmark(monks);

     connect(lmSaveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(landmarkSaveRequestHandler(QLandmarkAbstractRequest::State)));
     if (!lmSaveRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to save landmark, error code: &quot; &lt;&lt; lmSaveRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Saving landmark; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and see if there are any errors or not. We may reuse the <a href="qlandmarksaverequest.html">QLandmarkSaveRequest</a> by setting another landmark and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkSaveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (lmSaveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark save successfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark save was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="retrieving-categories-and-landmarks"></a>
<h2>Retrieving categories and landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<a name="retrieving-categories"></a>
<h4><b>Retrieving categories</b></h4>
<p>To retrieve categories we simply make the appropriate call to the <a href="qlandmarkmanager.html">QLandmarkManager</a>:</p>
<pre class="highlightedCode brush: cpp">     QList&lt;QLandmarkCategory&gt; categories = lmManager-&gt;categories();
     foreach(QLandmarkCategory category, categories) {
         qDebug() &lt;&lt; &quot;Found category: &quot; &lt;&lt; category.name();
     }</pre>
<p>When retrieving categories we may do so by the category ids. When the category data is needed we may use the id to retrieve a category object:</p>
<pre class="highlightedCode brush: cpp">     QList&lt;QLandmarkCategoryId&gt; categoryIds = lmManager-&gt;categoryIds();
     foreach(QLandmarkCategoryId id, categoryIds) {
         qDebug() &lt;&lt; &quot;Found category: &quot; &lt;&lt; lmManager-&gt;category(id).name();
     }</pre>
<a name="retrieving-landmarks"></a>
<h4><b>Retrieving landmarks</b></h4>
<p>To retrieve landmarks we create an appropriate filter, in this case a category filter. In this example, we also provide a <tt>limit</tt> of 5 and <tt>offset</tt> of 0 to only retrieve the first five landmarks and we provide a sort order to the <a href="qlandmarkmanager.html">QLandmarkManager</a>.</p>
<pre class="highlightedCode brush: cpp">         QList&lt;QLandmark&gt; landmarks;
         QLandmarkCategoryFilter filter;
         <span class="comment">//category is a previously retrieved QLandmarkCategory</span>
         filter.setCategory(category);
         QLandmarkNameSort sortOrder(Qt::AscendingOrder);
         landmarks = lmManager-&gt;landmarks(filter, 5, 0, sortOrder);
         foreach(const QLandmark &amp;landmark, landmarks) {
             qDebug() &lt;&lt; &quot;Found landmark:&quot; &lt;&lt; landmark.name();
         }</pre>
<p>Alternatively we can retrieve just the landmark ids. When the landmark data is needed at a later time we can use the id to retrieve the landmark object:</p>
<pre class="highlightedCode brush: cpp">         <span class="comment">//retrieval via ids</span>
         QList&lt;QLandmarkId&gt; landmarkIds;
         QLandmarkCategoryFilter filter;
         <span class="comment">//category is a previously retrieved QLandmarkCategory</span>
         filter.setCategory(category);
         QLandmarkNameSort sortOrder(Qt::AscendingOrder);
         landmarkIds = lmManager-&gt;landmarkIds(filter, 5, 0, sortOrder);
         foreach(const QLandmarkId &amp;id, landmarkIds) {
             qDebug() &lt;&lt; &quot;Found landmark:&quot; &lt;&lt; lmManager-&gt;landmark(id).name();
         }</pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<a name="retrieving-categories"></a>
<h4><b>Retrieving categories</b></h4>
<p>To retrieve categories we can use a <a href="qlandmarkcategoryfetchrequest.html">QLandmarkCategoryFetchRequest</a> (or if we wish to fetch id's then a <a href="qlandmarkcategoryidfetchrequest.html">QLandmarkCategoryIdFetchRequest</a>). The request's <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal is connected to a slot which detects whether the operation is complete. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//catFetchRequest was previously created with catFetchRequest = new QLandmarkCategoryFetchRequest(lmManager);</span>
     <span class="comment">//where lmManager is a QLandmarkManager*</span>

     connect(catFetchRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
             this, SLOT(categoryFetchRequestHandler(QLandmarkAbstractRequest::State)));

     if(!catFetchRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request categories, error code:&quot; &lt;&lt; catFetchRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested categories, awaiting results...&quot;;
     }</pre>
<p>For brevity, the slot does not process all the different request states. In our example, we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and if there are no errors, print out the categories.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categoryFetchRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (catFetchRequest-&gt;error() == QLandmarkManager::NoError) {
             QList&lt;QLandmarkCategory&gt; categories = catFetchRequest-&gt;categories();
             qDebug() &lt;&lt; &quot;Category fetch successfully completed&quot;;
             for(int i=0; i &lt; categories.count(); ++i) {
                 qDebug() &lt;&lt; categories[i].name();
             }
         }
         else {
             qDebug() &lt;&lt; &quot;Category fetch was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="retrieving-landmarks"></a>
<h4><b>Retrieving landmarks</b></h4>
<p>To retrieve landmarks we create an appropriate filter, in this case a category filter, and set it in a <a href="qlandmarkfetchrequest.html">QLandmarkFetchRequest</a>. In this example, we also provide a <tt>limit</tt> of 5 and <tt>offset</tt> of 0 to only retrieve the first five landmarks and we provide a sort order to the <a href="qlandmarkfetchrequest.html">QLandmarkFetchRequest</a>. (If we wanted to operate with ids we would use a <a href="qlandmarkidfetchrequest.html">QLandmarkIdFetchRequest</a> instead). The request's <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal is connected to a slot which detects whether the operation is complete. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp">     QLandmarkCategoryFilter filter;
     <span class="comment">//category is a previously retrieved QLandmarkCategory</span>
     filter.setCategory(category);
     QLandmarkNameSort sortOrder(Qt::AscendingOrder);

     <span class="comment">//lmFetchRequest was previously created with lmFetchRequest = new QLandmarkFetchRequest(lmManager);</span>
     <span class="comment">//where lmManager is a QLandmarkManger *</span>
     lmFetchRequest-&gt;setFilter(filter);
     lmFetchRequest-&gt;setLimit(5);
     lmFetchRequest-&gt;setOffset(0);
     lmFetchRequest-&gt;setSorting(sortOrder);

     connect(lmFetchRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
             this, SLOT(landmarkFetchRequestHandler(QLandmarkAbstractRequest::State)));

     if(!lmFetchRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request landmarks, error code:&quot; &lt;&lt; lmFetchRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested landmarks, awaiting results...&quot;;
     }</pre>
<p>For brevity, the slot does not process all the different request states. In our example, we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and if there are no errors, print out the landmarks.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkFetchRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         previousLastIndex = 0;
         if (lmFetchRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark fetch successfully completed&quot;;
             QList&lt;QLandmark&gt; landmarks = lmFetchRequest-&gt;landmarks();
             for(int i=0; i &lt; landmarks.count(); ++i) {
                 qDebug() &lt;&lt; landmarks[i].name();
             }
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark fetch was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="deleting-categories-and-landmarks"></a>
<h2>Deleting categories and landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<a name="deleting-a-category"></a>
<h4><b>Deleting a category</b></h4>
<p>To remove a category we simply pass the category id to a <a href="qlandmarkmanager.html">QLandmarkManager</a>.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//category is a previously retrieved QLandmarkCategory object</span>
     lmManager-&gt;removeCategory(category);</pre>
<a name="deleting-a-landmark"></a>
<h4><b>Deleting a landmark</b></h4>
<p>To remove a landmark we simply pass the landmark id to a <a href="qlandmarkmanager.html">QLandmarkManager</a>.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//landmark is a previously retrieved QLandmark object</span>
     lmManager-&gt;removeLandmark(landmark);</pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<a name="deleting-a-category"></a>
<h4><b>Deleting a category</b></h4>
<p>To remove a category we use a <a href="qlandmarkcategoryremoverequest.html">QLandmarkCategoryRemoveRequest</a> and set the id of the category we want to remove. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a></p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categoryRemoveRequest()
 {
     <span class="comment">//catRemoveRequest was created previously with catRemoveRequest = new QLandmarkCategoryRemoveRequest(lmManager);</span>
     <span class="comment">//where lmManager is a QLandmarkManager*</span>
     catRemoveRequest-&gt;setCategory(category); <span class="comment">//category is a previously retrieved QLandmarkCategory</span>

     connect(catRemoveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
         this, SLOT(categoryRemoveRequestHandler(QLandmarkAbstractRequest::State)));

     if(!catRemoveRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request category removal, error code:&quot; &lt;&lt; catRemoveRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested category removal, awaiting results...&quot;;
     }
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and see if there are any errors or not. We may reuse the <a href="qlandmarkcategoryremoverequest.html">QLandmarkCategoryRemoveRequest</a> by setting another category id and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categoryRemoveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (catRemoveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Category remove successfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Category remove was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="deleting-a-landmark"></a>
<h4><b>Deleting a landmark</b></h4>
<p>To remove a landmark we use a <a href="qlandmarkremoverequest.html">QLandmarkRemoveRequest</a> and set the id of the landmark we want to remove. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a></p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkRemoveRequest()
 {
     <span class="comment">//lmRemoveRequest was created previously with lmRemoveRequest = new QLandmarkRemoveRequest(lmManager);</span>
     <span class="comment">//where lmManager is a QLandmarkManager*</span>
     lmRemoveRequest-&gt;setLandmark(landmark);  <span class="comment">//landmark is a previously retrieved QLandmark</span>

     connect(lmRemoveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(landmarkRemoveRequestHandler(QLandmarkAbstractRequest::State)));
     if (!lmRemoveRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to remove landmark, error code: &quot; &lt;&lt; lmRemoveRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Removing landmark; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and see if there are any errors or not. We may reuse the <a href="qlandmarkremoverequest.html">QLandmarkRemoveRequest</a> by setting another landmark id and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkRemoveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (lmRemoveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark removal successfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark removal was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="importing-landmarks"></a>
<h2>Importing Landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<p>To import landmarks from a file we can simply provide the filename to the manager (the manager will try to automatically detect the file format). If we know the format we can provide one of the <a href="qlandmarkmanager.html#Gpx-var">format strings</a> as a parameter. Using a <a href="qlandmarkmanager.html#TransferOption-enum">QLandmarkManager::TransferOption</a>, an option for controlling import/export behavior, we can choose to include category data that comes with the landmarks(default), exclude category data meaning that the landmarks will not be associated with any categories or we can attach the landmarks to a single category meaning all the imported landmarks will be assigned to the given category.</p>
<p><b>Note:</b> Typically an import operation will take a long time to execute, it is therefore recommended that landmarks be imported asynchronously rather than synchronously.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//Import landmarks by providing just a file name.</span>
     landmarkManager-&gt;importLandmarks(&quot;places.lmx&quot;);

     <span class="comment">//Import landmarks by providing a given format.</span>
     landmarkManager-&gt;importLandmarks(&quot;places.xml&quot;, QLandmarkManager::Lmx);

     <span class="comment">//Import landmarks but ignore all categories</span>
     landmarkManager-&gt;importLandmarks(&quot;places.lmx&quot;,QLandmarkManager::Lmx,QLandmarkManager::ExcludeCategoryData);

     <span class="comment">//Import landmarks and assign them all to a single category.</span>
     landmarkManager-&gt;importLandmarks(&quot;places.lmx&quot;, QLandmarkManager::Lmx, QLandmarkManager::AttachSingleCategory,categoryId);</pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<p>To import landmarks we use a <a href="qlandmarkimportrequest.html">QLandmarkImportRequest</a> and set the filename of the file we want to import. We can set other import parameters as necessary such as the file format or the transfer option. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a></p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkImportRequest()
 {
     <span class="comment">//lmImportRequest was created with lmImportRequest = new QLandmarkImportRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager*</span>
     lmImportRequest-&gt;setFileName(&quot;places.lmx&quot;);

     <span class="comment">//if we wanted to we could specify various import parameters</span>
     <span class="comment">// lmImportRequest-&gt;setFormat(...);</span>
     <span class="comment">// lmImportRequest-&gt;setTransferOption(...);</span>

     connect(lmImportRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(landmarkImportRequestHandler(QLandmarkAbstractRequest::State)));
     if (!lmImportRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to import landmarks, error code: &quot; &lt;&lt; lmImportRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Importing landmarks; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and see if there are any errors or not. We may reuse the <a href="qlandmarkimportrequest.html">QLandmarkImportRequest</a> by setting filename and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkImportRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (lmImportRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark import successfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark import was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="exporting-landmarks"></a>
<h2>Exporting Landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<p>To export landmarks we can pass a filename and <a href="qlandmarkmanager.html#Gpx-var">format</a> to the manager. If we only want to export a subset of landmarks we can provide a list of landmark ids to export. We may also use a <a href="qlandmarkmanager.html#TransferOption-enum">QLandmarkManager::TransferOption</a> to decide whether we want to include(default) or exclude category data for the export (This will only have an affect if the supplied format supports categories.) Typically an export operation will take a long time to execute, it is therefore recommended that landmarks be exported asynchronously rather than synchronously.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//export to a given file with a specified format</span>
     landmarkManager-&gt;exportLandmarks(&quot;places.lmx&quot;, QLandmarkManager::Lmx);

     <span class="comment">//export a subset of landmarks defined by a set of landmark ids</span>
     landmarkManager-&gt;exportLandmarks(&quot;places.lmx&quot;, QLandmarkManager::Lmx,landmarkIds);

     <span class="comment">//Export landmarks but do not include any category data.</span>
     <span class="comment">//(If we provide an empty list of landmark ids, then all landmarks are exported)</span>
     landmarkManager-&gt;exportLandmarks(&quot;places.lmx&quot;, QLandmarkManager::Lmx,landmarkIds, QLandmarkManager::ExcludeCategoryData);</pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<p>To export landmarks we use a <a href="qlandmarkexportrequest.html">QLandmarkExportRequest</a> and set the filename of the file we want to export to, as well as the format we wish to use. We can set other export parameters as necessary, such as a list of ids of landmarks we want to export or the transfer option. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a></p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkExportRequest()
 {
     <span class="comment">//lmExportRequest was created with lmExportRequest = new QLandmarkExportRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager*</span>
     lmExportRequest-&gt;setFileName(&quot;places.lmx&quot;);
     lmExportRequest-&gt;setFormat(QLandmarkManager::Lmx);

     <span class="comment">//if we wanted to we could specify various export parameters</span>
     <span class="comment">// lmExportRequest-&gt;setLandmarkIds(...);</span>
     <span class="comment">// lmExportRequest-&gt;setTransferOption(...);</span>

     connect(lmExportRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(landmarkExportRequestHandler(QLandmarkAbstractRequest::State)));
     if (!lmExportRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to export landmarks, error code: &quot; &lt;&lt; lmExportRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Exporting landmarks; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the <a href="qlandmarkabstractrequest.html#State-enum">QLandmarkAbstractRequest::FinishedState</a> and see if there are any errors or not. We may reuse the <a href="qlandmarkexportrequest.html">QLandmarkExportRequest</a> by setting another filename and/or format and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkExportRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (lmExportRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark export successfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark export was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="c-examples"></a>
<h2>C++ Examples</h2>
<p>There are no C++ only, documented examples of the Landmarks API. However, there is the <a href="tutorials-mapsdemo.html">Maps Demo Tutorial</a> which is C++ only, though being a tutorial it is longer and more complicated than an example.</p>
<a name="qml-examples"></a>
<h2>QML Examples</h2>
<a name="landmark-map-qml-example"></a>
<h3><b>Landmark Map QML Example</b></h3>
<p>The <a href="declarative-location-landmarkmap.html">Landmark Map Example</a> shows how a mobile application might display some map information which includes landmark information imported from a landmark file.</p>
<a name="map-viewer-qml-example"></a>
<h3><b>Map Viewer QML Example</b></h3>
<p>The <a href="declarative-location-mapviewer.html">Map Viewer example</a> displays a map of the current location or failing that a hard-coded default location to display a typical map navigation application in form typical of a mobile phone.</p>
</div>
<!-- @@@landmarks.html -->
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
